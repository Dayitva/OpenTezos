(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[7698],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(n),u=i,h=m["".concat(l,".").concat(u)]||m[u]||d[u]||o;return n?a.createElement(h,r(r({ref:t},p),{},{components:n})):a.createElement(h,r({ref:t},p))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7705:function(e,t,n){"use strict";n.d(t,{Z:function(){return o}});var a=n(7294),i="root_2W3B",o=function(e){var t=e.children;return a.createElement("div",{className:i},t)}},899:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},metadata:function(){return l},toc:function(){return c},default:function(){return d}});var a=n(2122),i=n(9756),o=(n(7294),n(3905)),r=n(7705),s={id:"write-contracts-ligo",title:"Smart contract development in Pascaligo",authors:"Maxime Sallerin and Benjamin Pilia"},l={unversionedId:"ligo/write-contracts-ligo",id:"ligo/write-contracts-ligo",isDocsHomePage:!1,title:"Smart contract development in Pascaligo",description:"The language of smart contracts is Michelson, a stack-based language.",source:"@site/docs/ligo/write-contracts-ligo.md",sourceDirName:"ligo",slug:"/ligo/write-contracts-ligo",permalink:"/ligo/write-contracts-ligo",editUrl:"https://github.com/octo-technology/OpenTezos/tree/main/docs/ligo/write-contracts-ligo.md",version:"current",lastUpdatedBy:"AymericBethencourt",lastUpdatedAt:1620327772,formattedLastUpdatedAt:"5/6/2021",frontMatter:{id:"write-contracts-ligo",title:"Smart contract development in Pascaligo",authors:"Maxime Sallerin and Benjamin Pilia"},sidebar:"docs",previous:{title:"Installation",permalink:"/ligo/installation"},next:{title:"Language basics",permalink:"/ligo/language-basics"}},c=[{value:"Ligo Prerequisites",id:"ligo-prerequisites",children:[{value:"Built-in types",id:"built-in-types",children:[]},{value:"Type aliases",id:"type-aliases",children:[]},{value:"Constants &amp; Variables",id:"constants--variables",children:[]},{value:"Introduction to function",id:"introduction-to-function",children:[]},{value:"Main function",id:"main-function",children:[]},{value:"Ligo compilation",id:"ligo-compilation",children:[]}]},{value:"Storage definition",id:"storage-definition",children:[]},{value:"Parameter definition",id:"parameter-definition",children:[]},{value:"Code definition",id:"code-definition",children:[]},{value:"LIGO prerequisites",id:"ligo-prerequisites-1",children:[{value:"Records",id:"records",children:[]},{value:"Tuples",id:"tuples",children:[]},{value:"Functions in ligo",id:"functions-in-ligo",children:[]},{value:"Adding a new entrypoint with Ligo",id:"adding-a-new-entrypoint-with-ligo",children:[]},{value:"If condition",id:"if-condition",children:[]},{value:"Failwith",id:"failwith",children:[]},{value:"Timestamp",id:"timestamp",children:[]},{value:"Addresses",id:"addresses",children:[]},{value:"Tezos Module",id:"tezos-module",children:[]}]},{value:"Modifying the storage",id:"modifying-the-storage",children:[]},{value:"Creating a raffle session: entrypoint definition",id:"creating-a-raffle-session-entrypoint-definition",children:[]},{value:"Adding the OpenRaffle logic",id:"adding-the-openraffle-logic",children:[]},{value:"LIGO prerequisites: collections",id:"ligo-prerequisites-collections",children:[{value:"Lists",id:"lists",children:[]},{value:"Sets",id:"sets",children:[]},{value:"Maps",id:"maps",children:[]}]},{value:"Modifying the storage",id:"modifying-the-storage-1",children:[]},{value:"Adding the BuyTicket Entrypoint",id:"adding-the-buyticket-entrypoint",children:[]},{value:"Implementing the BuyTicket logic",id:"implementing-the-buyticket-logic",children:[]},{value:"LIGO prerequisites: Transactions",id:"ligo-prerequisites-transactions",children:[]},{value:"About randomness in smart contracts",id:"about-randomness-in-smart-contracts",children:[]},{value:"Adding the CloseRaffle entrypoint",id:"adding-the-closeraffle-entrypoint",children:[]},{value:"Implementing the CloseRaffle logic",id:"implementing-the-closeraffle-logic",children:[]},{value:"Winner selection scheme",id:"winner-selection-scheme",children:[]},{value:"Refactoring the OpenRaffle entrypoint",id:"refactoring-the-openraffle-entrypoint",children:[]},{value:"Refactoring the CloseRaffle entrypoint",id:"refactoring-the-closeraffle-entrypoint",children:[]}],p={toc:c};function d(e){var t=e.components,s=(0,i.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,a.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The language of smart contracts is Michelson, a stack-based language.\nHowever, this kind of language is not commonly used by developers.\nBesides, the more a smart contract grows, the more tedious it becomes to keep the code readable and clean.\nAs a result, it can deter many developers from trying to develop smart contracts for the Tezos Blockchain.\nLuckily, some high-level languages have been developed, in order to make it easier for developers to write smart contracts for the Tezos Blockchain.\nLIGO is one of these languages."),(0,o.kt)("p",null,"In this chapter, Pascaligo will be taught, based on the development of a raffle smart contract.\nThe most important aspects of Ligo will be covered, however, it is not a full development reference.\nThis chapter focuses on the way to develop a smart contract, each step introducing a new notion of the language.\nFor a full reference of the ligo language, see:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("a",{parentName:"li",href:"https://ligolang.org/docs/intro/introduction"},"Official Ligolang documentation")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("a",{parentName:"li",href:"https://tezosacademy.io/"},"Tezos academy"))),(0,o.kt)("p",null,"To learn the LIGO syntax from scratch, the best way is to start with some Tezos academy courses (the first 10 chapters are a good start)."),(0,o.kt)("p",null,"This chapter is driven by a smart contract development approach.\nEvery LIGO syntax needed for the example is explained in the LIGO prerequisite sections.\nThen, these LIGO notions will be used in the development of the smart contract."),(0,o.kt)("p",null,'The "LIGO prerequisite" parts can be skipped when there is no need no learn Pascaligo syntax'),(0,o.kt)(r.Z,{mdxType:"NotificationBar"},(0,o.kt)("p",null,(0,o.kt)("b",null,"DISCLAIMER: this smart contract is meant for educational purpose only, and is not suitable for any other use. OpenTezos cannot be held responsible for any other use."))),(0,o.kt)("h1",{id:"raffle-smart-contract"},"Raffle smart contract"),(0,o.kt)("p",null,"In this chapter, a simple raffle example is considered:\nan address (called the administrator) wants to organize a raffle, whose reward is a tz amount.\nThe administrator pays the reward to the winner with its own funds.\nAnyone can participate in the raffle, with a little fee. However, each address can participate only once.\nEach ticket has the same probability to be picked.\nAfter a given time, defined at the beginning of the raffle, the administrator closes the raffle, and rewards the winner.\nThis raffle can be divided into 3 steps:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"a raffle is opened, with a reward, for a given time"),(0,o.kt)("li",{parentName:"ol"},"during the raffle time, anyone can buy a raffle ticket."),(0,o.kt)("li",{parentName:"ol"},"the raffle is closed, the winner is randomly selected and rewarded with the prize.")),(0,o.kt)("p",null,"Only one raffle session can be ongoing."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Some choices have been made for educational purposes.")),(0,o.kt)(r.Z,{mdxType:"NotificationBar"},(0,o.kt)("p",null,(0,o.kt)("b",null,'About the word "ticket" :'),'ticket is a reserved word in Michelson and Ligo, introduced by the Edo protocol. In this chapter, the word "ticket" only refers to a raffle ticket.')),(0,o.kt)("h1",{id:"prerequisites-for-smart-contracts-development"},"Prerequisites for smart contracts development"),(0,o.kt)("p",null,"When developing smart contracts, two tools are extremely useful:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"a Ligo syntax support for your IDE"),(0,o.kt)("li",{parentName:"ol"},"a Ligo compiler")),(0,o.kt)("p",null,"These two tools will point out syntax errors and type errors.\nIt is recommended to compile a ligo smart contract as often as possible:\nerrors will be found early and will more easily be addressed."),(0,o.kt)("h1",{id:"smart-contract-initialization"},"Smart contract initialization"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"LIGO prerequisites in this part: everything that is required to create an empty smart contract."),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"Types, built-in types"),(0,o.kt)("li",{parentName:"ul"},"Constants, Variables"),(0,o.kt)("li",{parentName:"ul"},"Introduction to functions"),(0,o.kt)("li",{parentName:"ul"},"main function"),(0,o.kt)("li",{parentName:"ul"},"ligo compilation"))),(0,o.kt)("p",null,"A Michelson smart contract can be broken down into three parts:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"parameter"),": possible invocations of the smart contract"),(0,o.kt)("li",{parentName:"ol"},"a ",(0,o.kt)("strong",{parentName:"li"},"storage"),": persistent data structure, on-chain.\nIt can be read by everyone, but can only be changed by the contract itself."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"code"),": a sequence of instructions to be executed when invoking a smart contract")),(0,o.kt)("p",null,"These three pieces of information must also be defined in the Ligo code, in order to compile."),(0,o.kt)("p",null,"The first step is to create a .ligo file. It can be named anything.\nLet's create a file called raffle.ligo , which would compile a 'minimum' but viable contract."),(0,o.kt)("h2",{id:"ligo-prerequisites"},"Ligo Prerequisites"),(0,o.kt)("p",null,"LIGO is strongly and statically typed. This means that the compiler checks how a contract processes data,\nensuring that each function's expectations are met.\nIf it passes the test, the contract will not fail at run-time due to some inconsistent assumptions on data.\nThis is called type checking."),(0,o.kt)("p",null,"LIGO types are built on top of Michelson's type system."),(0,o.kt)("h3",{id:"built-in-types"},"Built-in types"),(0,o.kt)("p",null,"LIGO comes with all basic primitive types built-in like ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," and with a contract-specific type ",(0,o.kt)("inlineCode",{parentName:"p"},"address")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"tez")," for account balance or monetary transactions.\nLIGO also introduces composite types like ",(0,o.kt)("inlineCode",{parentName:"p"},"option"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"list")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," allowing to create complex data structures.\nYou can find all built-in types on the ",(0,o.kt)("a",{parentName:"p",href:"https://gitlab.com/ligolang/ligo/-/tree/dev#L35"},"LIGO gitlab"),"."),(0,o.kt)("p",null,"Below is a table of the most used built-in types. Most of them will be used in the raffle smart contract:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"),(0,o.kt)("th",{parentName:"tr",align:null},"Example"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"unit")),(0,o.kt)("td",{parentName:"tr",align:null},"carries no information"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"Unit"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"option")),(0,o.kt)("td",{parentName:"tr",align:null},"value of some type or none"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'Some ("this string is defined")'),", ",(0,o.kt)("inlineCode",{parentName:"td"},"(None: option string)"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"string")),(0,o.kt)("td",{parentName:"tr",align:null},"Sequence of character"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'"This is a string"'))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"address")),(0,o.kt)("td",{parentName:"tr",align:null},"Address of an implicit account"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address)'))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"int")),(0,o.kt)("td",{parentName:"tr",align:null},"Positive or negative integer"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"-5"),", ",(0,o.kt)("inlineCode",{parentName:"td"},"int (1n)"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"nat")),(0,o.kt)("td",{parentName:"tr",align:null},"Positive integer"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"0n"),", ",(0,o.kt)("inlineCode",{parentName:"td"},"abs (1)"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"tez"),", ",(0,o.kt)("inlineCode",{parentName:"td"},"tz"),", ",(0,o.kt)("inlineCode",{parentName:"td"},"mutez")),(0,o.kt)("td",{parentName:"tr",align:null},"Amount in tz or mutez"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"5mutez"),", ",(0,o.kt)("inlineCode",{parentName:"td"},"10tez"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"bool")),(0,o.kt)("td",{parentName:"tr",align:null},"Boolean: true or false"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"True"),", ",(0,o.kt)("inlineCode",{parentName:"td"},"False"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"timestamp")),(0,o.kt)("td",{parentName:"tr",align:null},"Timestamp (bakers are responsible for providing the given current timestamp)"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'("2000-01-01T10:10:10Z" : timestamp)'),", ",(0,o.kt)("inlineCode",{parentName:"td"},"Tezos.now"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"bytes")),(0,o.kt)("td",{parentName:"tr",align:null},"Sequence of bytes"),(0,o.kt)("td",{parentName:"tr",align:null},"0x12e4")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"list (type)")),(0,o.kt)("td",{parentName:"tr",align:null},"List definition. The same element can be found several times in a list"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"list [1; 2; 2]"),", ",(0,o.kt)("inlineCode",{parentName:"td"},"nil"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"set (type)")),(0,o.kt)("td",{parentName:"tr",align:null},"Set definition. The same element cannot be found several times in a list"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"set []"),", ",(0,o.kt)("inlineCode",{parentName:"td"},"set [3; 2; 2; 1]"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"type1 * type2 ... * typeN")),(0,o.kt)("td",{parentName:"tr",align:null},"Tuple definition"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'("Alice", 5n, True)'))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"(keyType, valueType) map")),(0,o.kt)("td",{parentName:"tr",align:null},"Map an element of type keyType to an element of type valueType. Meant for finite maps"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"Map.empty"),", ",(0,o.kt)("inlineCode",{parentName:"td"},'Map.literal [(("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address), (1,2)); (("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address), (0,3))]'))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"(keyType, valueType) big_map")),(0,o.kt)("td",{parentName:"tr",align:null},"Map an element of type keyType to an element of type valueType. Meant for huge maps"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"Big_map.empty"),", ",(0,o.kt)("inlineCode",{parentName:"td"},'Big_map.literal [(("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address), (1,2)); (("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address), (0,3))]'))))),(0,o.kt)("h3",{id:"type-aliases"},"Type aliases"),(0,o.kt)("p",null,"Type aliasing consists of renaming a given type when the context calls for a more precise name.\nThis increases readability and maintainability of your smart contracts.\nFor example, we can choose to alias a string type as an animal breed -\nthis will allow us to communicate our intent with added clarity."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'type breed is string\nconst dog_breed : breed = "Saluki"\n')),(0,o.kt)("p",null,"The real value of types aliases lies in the alias for complex data structures, such as records (described below).\nThis way, these structures are more easily handled."),(0,o.kt)("h3",{id:"constants--variables"},"Constants & Variables"),(0,o.kt)("h4",{id:"constants"},"Constants"),(0,o.kt)("p",null,"Constants are by design immutable, which means their values cannot be reassigned.\nPut in another way, they can only be assigned once, at their declaration.\nA constant is defined by a name, type and a value:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const age : int = 25\n")),(0,o.kt)("h4",{id:"variables"},"Variables"),(0,o.kt)("p",null,"Variables, unlike constants, are mutable.\nThey cannot be declared in a global scope, but they can be declared and used within functions,\nor as function parameters."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var c: int := 2 + 3\nc := c - 3\n")),(0,o.kt)("p",null,"\u26a0\ufe0f The assignment operator is different: ",(0,o.kt)("inlineCode",{parentName:"p"},":=")," for var, instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"=")," for constants."),(0,o.kt)("h3",{id:"introduction-to-function"},"Introduction to function"),(0,o.kt)("p",null,"As in any other language, functions can be defined in Ligo.\nThere are several ways to define a function, but the header is always the same:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function <functionName> (const param1 : <param2Type>, const param2 : <param2Type>...): <returnType> is\n    <code>\n")),(0,o.kt)("p",null,"Functions will be detailed below. At this point, since this main function does nothing,\nit will use a blockless function definition."),(0,o.kt)("h3",{id:"main-function"},"Main function"),(0,o.kt)("p",null,"A main function takes two parameters,\nthe ",(0,o.kt)("strong",{parentName:"p"},"contract parameter")," and the ",(0,o.kt)("strong",{parentName:"p"},"on-chain storage"),",\nand returns a pair made of a ",(0,o.kt)("strong",{parentName:"p"},"list of operations")," and a ",(0,o.kt)("strong",{parentName:"p"},"(new) storage"),"."),(0,o.kt)("br",null),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(9784).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 1: Main function"),(0,o.kt)("br",null),(0,o.kt)("p",null,"The type of the contract parameter and the storage are up to the contract designer,\nbut the type for the list operations is not."),(0,o.kt)("p",null,"The return type of main function is as follows,\nassuming that the ",(0,o.kt)("inlineCode",{parentName:"p"},"storage")," type  has been defined elsewhere."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type storage is ...  // Any name, any type\ntype return is list (operation) * storage\n")),(0,o.kt)("p",null,"Lists and tuple will be detailed in the Collections part."),(0,o.kt)("p",null,"The contract storage can only be modified by activating a main function:\ngiven the state of the storage on-chain,\na main function specifies how to create another state for it,\ndepending on the contract's parameter."),(0,o.kt)("p",null,"Here is an example where the storage is a single natural number without any entrypoint."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type parameter is unit\ntype storage is nat\ntype return is list (operation) * storage\n\nfunction save (const action : parameter; const store : storage) : return is\n((nil : list (operation)), store)\n")),(0,o.kt)("h3",{id:"ligo-compilation"},"Ligo compilation"),(0,o.kt)("p",null,"The ligo code above should compile now, with this command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"$ ligo compile-contract <ligoFile> <mainFunction>\n")),(0,o.kt)("p",null,"If the compilation is successful, the output will be the Michelson code."),(0,o.kt)("p",null,"It is recommended to run this command as often as possible, to check both code syntax and types."),(0,o.kt)("h2",{id:"storage-definition"},"Storage definition"),(0,o.kt)("p",null,"The first step is to define the storage.\nContract storage holds the contract data: it can be a single value or a complex structure.\nThe storage definition is a ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," instruction. First, the storage will be as simple as possible: empty"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type storage is unit\n")),(0,o.kt)("h2",{id:"parameter-definition"},"Parameter definition"),(0,o.kt)("p",null,"Smart contracts generally have one or several parameters, but it is not mandatory.\nAt this point, the parameter definition will be skipped. They will be defined later on, in this chapter.\nTo define a smart contract without any parameter:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type raffleEntrypoints is unit\n")),(0,o.kt)("h2",{id:"code-definition"},"Code definition"),(0,o.kt)("p",null,"The last piece of information of the smart contract is the code definition.\nA smart contract can of course execute no instruction, but it must always return two things:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"a list of operations"),(0,o.kt)("li",{parentName:"ol"},"the storage")),(0,o.kt)("p",null,'The ligo compiler expects a smart contract to have at least one function, which is the "main" function.\nIt does not have to be named that way. In this chapter, the "main" function will be named main:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type storage is unit\ntype raffleEntrypoints is unit\n\nfunction main (const action : raffleEntrypoints; const store : storage): list (operation) * storage is\n    ((nil: list(operation)), store)\n")),(0,o.kt)("p",null,"This main function returns a tuple of the two required elements."),(0,o.kt)("p",null,"The raffle smart contract can now be compiled:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"$ ligo compile-contract raffle.ligo main\n")),(0,o.kt)("h1",{id:"smart-contract-development--launch-raffle-entrypoint"},"Smart Contract development\xa0: launch raffle entrypoint"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"LIGO prerequisites in this part: you will learn how to define a more complex storage,\nhow to add an entrypoint, how to dispatch the control flow in the main function and\nperform checks and access control"),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"Record"),(0,o.kt)("li",{parentName:"ul"},"Tuples"),(0,o.kt)("li",{parentName:"ul"},"functions"),(0,o.kt)("li",{parentName:"ul"},"Entrypoint"),(0,o.kt)("li",{parentName:"ul"},"variant"),(0,o.kt)("li",{parentName:"ul"},"pattern matching"),(0,o.kt)("li",{parentName:"ul"},"if condition"),(0,o.kt)("li",{parentName:"ul"},"failwith"),(0,o.kt)("li",{parentName:"ul"},"types: addresses, timestamp"),(0,o.kt)("li",{parentName:"ul"},"Tezos Module"))),(0,o.kt)("p",null,"The LIGO code is compiling, but the Michelson code does nothing:\nthere is no storage, no parameter, and the smart contract returns an empty list of operation and an empty storage.\nAs detailed in the ",(0,o.kt)("a",{parentName:"p",href:"#raffle-smart-contract"},"Raffle smart contract")," section,\nthe smart contract should perform three actions:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"launch a raffle"),(0,o.kt)("li",{parentName:"ol"},"sell tickets (which that the caller can buy a ticket)"),(0,o.kt)("li",{parentName:"ol"},"close the raffle, and reward the winner")),(0,o.kt)("p",null,"Each one of these actions can be coded into an entrypoint."),(0,o.kt)("h2",{id:"ligo-prerequisites-1"},"LIGO prerequisites"),(0,o.kt)("h3",{id:"records"},"Records"),(0,o.kt)("p",null,"The record` type is a structure that holds several pieces of information: each piece is accessed thanks to a field name."),(0,o.kt)("p",null,"It is extremely useful for the storage definition and for any object that should hold different types of information."),(0,o.kt)("h4",{id:"defining-records"},"Defining records"),(0,o.kt)("p",null,"To instantiate a record, the ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," instruction is used:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type user is\n  record [\n    id : nat;\n    is_admin : bool;\n    name : string\n  ]\n")),(0,o.kt)("p",null,"The name and type of fields are defined at the record definition.\nIt cannot be changed afterwards: a new field cannot be added, nor the type changed"),(0,o.kt)("p",null,"Here is how to define an associated record value:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const rogers : user =\n  record [\n    id = 1n;\n    is_admin = true;\n    name = "Rogers"\n  ]\n')),(0,o.kt)("h4",{id:"accessing-record-fields"},"Accessing Record Fields"),(0,o.kt)("p",null,"Accessing the contents of a given field can be done with the ",(0,o.kt)("inlineCode",{parentName:"p"},".")," infix operator."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const rogers_admin : bool = roger.is_admin\n")),(0,o.kt)("h4",{id:"updating-a-record"},"Updating a record"),(0,o.kt)("p",null,"Modifying values in a ",(0,o.kt)("inlineCode",{parentName:"p"},"record")," can be done with :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const rogersNotAdmin : user = u with record [is_admin = False]\n")),(0,o.kt)("p",null,"After this update, the pieces of information held by the ",(0,o.kt)("em",{parentName:"p"},"rogers")," record are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"id: 1n"),(0,o.kt)("li",{parentName:"ul"},"is_admin: false"),(0,o.kt)("li",{parentName:"ul"},'name: "Rogers"')),(0,o.kt)("p",null,"Modifying a ",(0,o.kt)("inlineCode",{parentName:"p"},"record")," value can also be done with a ",(0,o.kt)("inlineCode",{parentName:"p"},"patch")," instruction:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function change_name (const u : user) : user is\n  block {\n      patch u with record [name = "Mark"]\n  } with u\n')),(0,o.kt)("h3",{id:"tuples"},"Tuples"),(0,o.kt)("p",null,"Tuples gather multiple fields into a single structure.\nTuple definition combines multiple types into a single type.\nA tuple data structure is ordered which means we can access to each element of the tuple by its position.\nUnlike ",(0,o.kt)("inlineCode",{parentName:"p"},"record")," type, the tuple fields are unnamed."),(0,o.kt)("p",null,"A tuple example would be an ",(0,o.kt)("inlineCode",{parentName:"p"},"(x,y)")," pair."),(0,o.kt)("h4",{id:"defining-tuples"},"Defining Tuples"),(0,o.kt)("p",null,"A tuple can be defined by using the * operator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'type full_name is (string * string)\nconst captain_full_name : full_name = ("Roger", "Johnson")\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Tuple can be defined without type aliasing:"),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const captain_full_name : (string * string) = ("Roger", "Johnson")\n'))),(0,o.kt)("h4",{id:"accessing-components"},"Accessing Components"),(0,o.kt)("p",null,"Each component of a tuple can be accessed by its position:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const captain_first_name : string = captain_full_name.0\nconst captain_last_name : string = captain_full_name.1\n")),(0,o.kt)("p",null,"\u26a0\ufe0f Tuple components are zero-indexed, that is, the first component has the index ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,o.kt)("h4",{id:"update-components"},"Update Components"),(0,o.kt)("p",null,"A tuple component can be modified, by assigning values as if it were a variable:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'captain_full_name.1 := "Carter"\n')),(0,o.kt)("h3",{id:"functions-in-ligo"},"Functions in ligo"),(0,o.kt)("p",null,"LIGO functions are the basic building block of contracts.\nEach entrypoint of a contract executes a function\nand each smart contract must have at least one ",(0,o.kt)("strong",{parentName:"p"},"main")," function\nthat dispatches the control flow to other functions."),(0,o.kt)("p",null,"When calling a function,\nLIGO makes a copy of the arguments but also of the environment variables."),(0,o.kt)("p",null,"Therefore, any modification to these will not be reflected outside the scope of the function\nand will be lost if not explicitly returned by the function."),(0,o.kt)("p",null,"There are two syntaxes for functions in PascaLIGO, Block Functions and Blockless Functions:"),(0,o.kt)("h4",{id:"block-functions"},"Block functions"),(0,o.kt)("p",null,"In PascaLIGO, blocks allow for the sequential composition of instructions into an isolated scope.\nEach block needs to include at least one instruction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"block { \n    const b : int = 10\n    a := a + b \n}\n")),(0,o.kt)("p",null,"If a placeholder is needed, the instruction ",(0,o.kt)("inlineCode",{parentName:"p"},"skip")," leaves\nthe state unchanged.  The rationale for ",(0,o.kt)("inlineCode",{parentName:"p"},"skip")," instead of a truly\nempty block is that it prevents you from writing an empty block by\nmistake."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"block { skip }\n")),(0,o.kt)("p",null,"Functions in PascaLIGO are defined using the following syntax:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function <name> (<parameters>) : <return_type> is \n  block {\n   <operations and instructions>\n  } with <returned_value>\n")),(0,o.kt)("p",null,"For instance :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function add (const a : int; const b : int) : int is\n  block {\n    const sum : int = a + b\n  } with sum\n")),(0,o.kt)("h4",{id:"blockless-functions"},"Blockless functions"),(0,o.kt)("p",null,"Functions containing all of their logic into a single expression can be defined without a block.\nThe add function above can be re-written as a blockless function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function add (const a: int; const b : int) : int is a + b\n")),(0,o.kt)("h4",{id:"anonymous-functions-aka-lambdas"},"Anonymous functions (a.k.a. lambdas)"),(0,o.kt)("p",null,"It is possible to define functions without assigning them a name.\nThey are useful when they are passed as arguments,\nor assigned to a key in a record or a map."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function increment (const b : int) : int is\n   (function (const a : int) : int is a + 1) (b)\nconst a : int = increment (1); // a = 2\n")),(0,o.kt)("p",null,"If the example above seems contrived, here is a more common design pattern for lambdas:\nto be used as parameters to functions.\nConsider the use case of having a list of integers and mapping the increment function to all its elements."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function incr_map (const l : list (int)) : list (int) is\n  List.map (function (const i : int) : int is i + 1, l)\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},'For the input "list ',"[1;2;3]",'" the output will be ',"[2;3;4]")),(0,o.kt)("h4",{id:"recursive-function"},"Recursive function"),(0,o.kt)("p",null,"LIGO functions are not recursive by default,\nthe user need to indicate that the function is recursive."),(0,o.kt)("p",null,"At the moment,\nrecursive function are limited to one (possibly tupled) parameter\nand recursion is limited to tail recursion (i.e the recursive call should be the last expression of the function)"),(0,o.kt)("p",null,"In PascaLigo recursive functions are defined using the ",(0,o.kt)("inlineCode",{parentName:"p"},"recursive")," keyword."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"recursive function sum (const n : int; const acc: int) : int is\n  if n<1 then acc else sum(n-1,acc+n)\n")),(0,o.kt)("h3",{id:"adding-a-new-entrypoint-with-ligo"},"Adding a new entrypoint with Ligo"),(0,o.kt)("p",null,"In LIGO, the design pattern is to have one main function called ",(0,o.kt)("inlineCode",{parentName:"p"},"main"),",\nthat dispatches the control flow according to its parameters.\nThose functions called for those actions are called entrypoints."),(0,o.kt)("p",null,"As an analogy, in the C programming language,\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function is the unique main function and any function called from it would be an entrypoint."),(0,o.kt)("p",null,"The parameter of the contract is then a variant type (described below),\nand, depending on the constructors of that type,\ndifferent functions in the contract are called.\nIn other terms, the unique main function dispatches the control flow\ndepending on a pattern matching on the contract parameter."),(0,o.kt)("h4",{id:"variant-type"},"Variant type"),(0,o.kt)("p",null,"A variant type is a user-defined, or a built-in type (in case of options) that defines a type by cases.\nA number of cases is defined in the type definition. The value of a variable of this type must be included in these cases.\nThe simplest variant type is equivalent to the enumerated types found in Java, C++, JavaScript etc."),(0,o.kt)("p",null,"Here is how we define a bit as being either 1 or 0 (and nothing else):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type bit is One | Zero\nconst closed_switch : bit = One\nconst open_switch : coin = Zero\n")),(0,o.kt)("h4",{id:"pattern-matching"},"Pattern Matching"),(0,o.kt)("p",null,"Pattern matching is similar to the ",(0,o.kt)("inlineCode",{parentName:"p"},"switch")," construct in Javascript,\nand can be used to route the program's control flow based on the value of a variant.\nConsider for example the definition of a power switch that turn on/off a light."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type bit is One | Zero\n\nfunction power_switch (const b : bit) : bit is\n  case b of\n    One -> Zero\n  | Zero -> One\n  end\n")),(0,o.kt)("h3",{id:"if-condition"},"If condition"),(0,o.kt)("p",null,"Conditional logic to ",(0,o.kt)("em",{parentName:"p"},"fork")," the control flow depending on the state."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function isSmall (const n : nat) : bool is\nif n < 10n then true else false\n")),(0,o.kt)("p",null,"\u26a0\ufe0f When the branches of the conditional are not a single expression, as above, we need a ",(0,o.kt)("inlineCode",{parentName:"p"},"block"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"if x < y then\n    block {\n        x := x + 1;\n        y := y - 1\n    }\nelse skip;\n")),(0,o.kt)("h3",{id:"failwith"},"Failwith"),(0,o.kt)("p",null,"The keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"failwith")," throws an exception and stop the execution of the smart contract."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"failwith(<string_message>)\n")),(0,o.kt)("h3",{id:"timestamp"},"Timestamp"),(0,o.kt)("p",null,"LIGO features timestamps are responsible for providing the given current timestamp for the contract."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const today : timestamp = Tezos.now\nconst one_day : int = 86_400\nconst in_24_hrs : timestamp = today + one_day\nconst some_date : timestamp = ("2000-01-01T10:10:10Z" : timestamp)\nconst one_day_later : timestamp = some_date + one_day\n')),(0,o.kt)("h3",{id:"addresses"},"Addresses"),(0,o.kt)("p",null,"Addresses are very likely to be used in any smart contract.\nYou can define Tezos addresses by casting a ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," value to an ",(0,o.kt)("inlineCode",{parentName:"p"},"address")," type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const my_account : address = ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address)\n')),(0,o.kt)("p",null,"\u26a0\ufe0f You will not see a compilation error if the address you enter is wrong, but the execution will fail."),(0,o.kt)("h3",{id:"tezos-module"},"Tezos Module"),(0,o.kt)("p",null,"The Tezos module is a set of LIGO instructions, that query the state of the Tezos blockchain.\nIt is useful when the smart contract needs to know who is calling an entrypoint, if enough funds have been transferred..."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.balance"),": Get the balance for the contract."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.amount"),": Get the amount of tez provided by the sender to complete this transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.sender"),": Get the address that initiated the current transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.self_address"),": Get the address of the currently running contract."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.source"),": Get the originator (address) of the current transaction.\nThat is, if a chain of transactions led to an execution, you get the address that began the chain.\nNot to be confused with Tezos.sender,\nwhich gives the address of the contract or user which directly caused the current transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.chain_id"),": Get the identifier of the chain to distinguish between main and test chains.")),(0,o.kt)("h2",{id:"modifying-the-storage"},"Modifying the storage"),(0,o.kt)("p",null,"The first entrypoint of the Raffle smart contract illutrates the basics of Pascaligo, covered above."),(0,o.kt)("p",null,"Before coding the logic of the first action (opening a raffle session), the storage has to be modified to hold such a raffle.\nThe contract needs an ",(0,o.kt)("strong",{parentName:"p"},"administrator"),": he will launch a raffle session, with a ",(0,o.kt)("strong",{parentName:"p"},"description"),".\nWhen the raffle is ",(0,o.kt)("strong",{parentName:"p"},"opened"),", it should be clearly noted in the storage.\nThis raffle will need a ",(0,o.kt)("strong",{parentName:"p"},"reward")," and will be ongoing for a given ",(0,o.kt)("strong",{parentName:"p"},"time"),"."),(0,o.kt)("p",null,"So, 5 pieces of information are needed:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the raffle administrator"),(0,o.kt)("li",{parentName:"ul"},"a description about the raffle"),(0,o.kt)("li",{parentName:"ul"},"is the raffle opened?"),(0,o.kt)("li",{parentName:"ul"},"the reward in tz"),(0,o.kt)("li",{parentName:"ul"},"the raffle end date.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"What would the types for each piece of information ?")),(0,o.kt)("p",null,"For each piece of information, the corresponding type is:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"raffle administrator: address"),(0,o.kt)("li",{parentName:"ul"},"raffle description: string"),(0,o.kt)("li",{parentName:"ul"},"raffle opened ? : boolean"),(0,o.kt)("li",{parentName:"ul"},"reward: tez"),(0,o.kt)("li",{parentName:"ul"},"raffle end date: timestamp")),(0,o.kt)("p",null,"So far, the storage was empty, thanks to the ",(0,o.kt)("inlineCode",{parentName:"p"},"unit")," type.\nThe storage now needs to hold five pieces of information, of different types.\nSeveral values can be held in a ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),", but they must have the same type. Besides, ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," are not meant to keep the same number of elements."),(0,o.kt)("p",null,"The correct way to define a storage is to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"record")," type."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Modify the storage smart contract to hold the 5 pieces of information, defined ",(0,o.kt)("a",{parentName:"p",href:"#modifying-the-storage"},"at the beginning of this part")),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type storage is record [\n    admin : address;\n    close_date : timestamp;\n    jackpot : tez;\n    description : string;\n    raffle_is_open : bool;\n]\n"))),(0,o.kt)("h2",{id:"creating-a-raffle-session-entrypoint-definition"},"Creating a raffle session: entrypoint definition"),(0,o.kt)("p",null,'The contract storage can now hold a raffle session.\nThe contract has to provide the users with a way of creating a raffle session.\nTo do that, it needs an entrypoint that perform such an action:\nthis new entrypoint should be named "OpenRaffle" and would allow the administrator to open a raffle.'),(0,o.kt)("p",null,"So far, there is no entrypoint into this smart contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type raffleEntrypoints is unit\n")),(0,o.kt)("p",null,"Adding the OpenRaffle entrypoint means to define the raffle entrypoint as a variant:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type raffleEntrypoints is OpenRaffle of unit\n")),(0,o.kt)("p",null,"raffleEntrypoints is now a variant: OpenRaffle (because of ",(0,o.kt)("inlineCode",{parentName:"p"},"of unit"),") does not expect any argument."),(0,o.kt)("p",null,"In order to be exposed, OpenRaffle needs to be handled in a pattern matching, in the main function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function main (const action : raffleEntrypoints; const store : storage):  list (operation) * storage is\n    case action of\n        OpenRaffle -> ((nil: list(operation)), store)\n    end;\n\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Notice that the contract ",(0,o.kt)("strong",{parentName:"p"},"parameter")," (",(0,o.kt)("em",{parentName:"p"},"raffleEntrypoints")," variant) is requiring no parameter (",(0,o.kt)("inlineCode",{parentName:"p"},"unit"),").\nFor now, this smart contract has only a single default entrypoint with no argument.\nThe ",(0,o.kt)("em",{parentName:"p"},"storage")," type is used as the second parameter of the ",(0,o.kt)("em",{parentName:"p"},"main")," function. ")),(0,o.kt)("p",null,"The smart contract now looks like (and is compiling):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type raffleEntrypoints is OpenRaffle of unit\n\ntype storage is record [\n    admin : address;\n    close_date : timestamp;\n    jackpot : tez;\n    description : string;\n    raffle_is_open : bool;\n    ]\n\ntype returnType is list (operation) * storage\n\nfunction main (const action : raffleEntrypoints; const store : storage): returnType is\n    case action of\n        OpenRaffle -> ((nil: list(operation)), store)\n    end;\n\n")),(0,o.kt)("p",null,"Despite the definition of a more complex storage, the execution of the smart contract still does nothing.\nThe smart contract should at least expect some parameters and update his storage (thanks to the logic implementation)."),(0,o.kt)("p",null,"To open a raffle, several pieces of information have to be sent:\nthe reward, the closing date, and a raffle description\nLet's define a type for these parameters:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type openRaffleParameter is tez * timestamp * option(string)\n")),(0,o.kt)("p",null,"It is declared as a tuple:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"tez: amount of the reward"),(0,o.kt)("li",{parentName:"ul"},"timestamp: closing date"),(0,o.kt)("li",{parentName:"ul"},"option(string): an optional description")),(0,o.kt)("p",null,"The OpenRaffle entrypoint must expect these parameters:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type openRaffleParameter is tez * timestamp * option(string)\ntype raffleEntrypoints is OpenRaffle of openRaffleParameter\n")),(0,o.kt)("p",null,"Finally, the parameters must be added in the control flow from the main function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type openRaffleParameter is tez * timestamp * option(string)\ntype raffleEntrypoints is OpenRaffle of openRaffleParameter\n\ntype storage is record [\n    admin : address;\n    close_date : timestamp;\n    jackpot : tez;\n    description : string;\n    raffle_is_open : bool;\n    ]\n\ntype returnType is list (operation) * storage\n\nfunction main (const action : raffleEntrypoints; const store : storage): returnType is\n    case action of\n        OpenRaffle (param) -> ((nil: list(operation)), store)\n    end;\n\n")),(0,o.kt)("p",null,"It output a Michelson code, which does nothing, but there is slight change in the parameter section:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"{ parameter (pair (pair mutez timestamp) (option string)) ;\n  storage int ;\n  code { CDR ; NIL operation ; PAIR } }\n")),(0,o.kt)("p",null,"The openRaffleParameter are expected in the parameter section."),(0,o.kt)("h2",{id:"adding-the-openraffle-logic"},"Adding the OpenRaffle logic"),(0,o.kt)("p",null,"The last step is to implement the logic of this entrypoint, in a function, which would update the storage."),(0,o.kt)("p",null,"Let's create an empty function. This function expects the three needed parameters,\nand returns the standard list of operations and the updated store:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option(string); const store : storage) : returnType is\n    block { skip } with ((nil: list(operation)), store)\n")),(0,o.kt)("p",null,"The first step is to check if the entrypoint is called by the administrator. If not, it should raise an exception.\nThe check is performed by an association of an ",(0,o.kt)("inlineCode",{parentName:"p"},"if")," condition and a ",(0,o.kt)("inlineCode",{parentName:"p"},"failwith"),".\nThe address calling the entrypoint should match the address in the storage. It is called access control:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option(string); const store : storage) : returnType is\n    block {\n      if Tezos.source =/= store.admin then failwith("administrator not recognized")\n      else {\n        skip\n      }\n    } with ((nil: list(operation)), store)\n')),(0,o.kt)("p",null,"A second check has to be performed: a raffle cannot be opened if the previous one is not yet closed.\nA boolean gives this piece of information in the storage: raffle_is_open"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option(string); const store : storage) : returnType is\n    block {\n      if Tezos.source =/= store.admin then failwith("Administrator not recognized.")\n      else {\n        if not store.raffle_is_open then {\n            skip\n        } else {\n          failwith("A raffle is already open.")\n        }\n      }\n    } with ((nil: list(operation)), store)\n')),(0,o.kt)("p",null,"A third check is performed about the reward: the funds sent must match the raffle reward."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option (string); const store : storage) : returnType is\n  block {\n    if Tezos.source =/= store.admin\n    then failwith ("Administrator not recognized.")\n    else {\n      if not store.raffle_is_open then {\n        if Tezos.amount < jackpot_amount then failwith ("The administrator does not own enough tz.")\n        else {\n            skip\n        }\n      }\n      else {\n        failwith ("A raffle is already open.")\n      }\n    }\n  } with ((nil : list (operation)), store)\n')),(0,o.kt)("p",null,"One finale check is performed about the raffle closing date: the raffle should last at least a week."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option (string); const store : storage) : returnType is\n  block {\n    if Tezos.source =/= store.admin\n    then failwith ("Administrator not recognized.")\n    else {\n      if not store.raffle_is_open then {\n        if Tezos.amount < jackpot_amount then failwith ("The administrator does not own enough tz.")\n        else {\n          const today : timestamp = Tezos.now;\n          const seven_day : int = 7 * 86400;\n          const in_7_day : timestamp = today + seven_day;\n          const is_close_date_not_valid : bool = close_date < in_7_day;\n          if is_close_date_not_valid then failwith("The raffle must remain open for at least 7 days.")\n          else {\n            skip\n          }\n        }\n      }\n      else {\n        failwith ("A raffle is already open.")\n      }\n    }\n  } with ((nil : list (operation)), store)\n')),(0,o.kt)("p",null,"The logic is finally implemented.\nFor this entrypoint, the only thing to do is to store the pieces of information of the raffle:\nthe reward, the closing date, the raffle description.\nIn addition, the storage should indicate that there is an ongoing raffle.\nThe storage needs to be updated with these pieces of information. "),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Take a look at how the description is added to the storage (it is an ",(0,o.kt)("inlineCode",{parentName:"p"},"option"),").")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option (string); const store : storage) : returnType is\n  block {\n    if Tezos.source =/= store.admin\n    then failwith ("Administrator not recognized.")\n    else {\n      if not store.raffle_is_open then {\n        if Tezos.amount < jackpot_amount then failwith ("The administrator does not own enough tz.")\n        else {\n          const today : timestamp = Tezos.now;\n          const seven_day : int = 7 * 86400;\n          const in_7_day : timestamp = today + seven_day;\n          const is_close_date_not_valid : bool = close_date < in_7_day;\n          if is_close_date_not_valid then failwith("The raffle must remain open for at least 7 days.")\n          else {\n            patch store with record [\n            jackpot = jackpot_amount;\n            close_date = close_date;\n            raffle_is_open = True;\n            ];\n\n            case description of\n              Some(d) -> patch store with record [description=d]\n            | None -> {skip}\n            end\n          }\n        }\n      }\n      else {\n        failwith ("A raffle is already open.")\n      }\n    }\n  } with ((nil : list (operation)), store)\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Keep in mind:"),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"to check entrypoint inputs as much as possible"),(0,o.kt)("li",{parentName:"ul"},"that comparisons and mathematical operations are carried out the same way for any type (int, tez, timestamp...)"),(0,o.kt)("li",{parentName:"ul"},"the storage is used and updated in an entrypoint"))),(0,o.kt)("h1",{id:"smart-contract-development--buy-ticket-entrypoint"},"Smart Contract development\xa0: Buy ticket entrypoint"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"LIGO prerequisites in this part: you will learn how to use collections with this second entrypoint.\nIt will also be the opportunity for you to use again functions and performs checks")),(0,o.kt)("p",null,"The second entrypoint can be freely called by everyone who wants to buy a ticket.\nIn this use case, each address can only buy one ticket, which costs 1 tz."),(0,o.kt)("p",null,"Two additional pieces of information have to be kept:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"who is taking part in the raffle"),(0,o.kt)("li",{parentName:"ol"},"who is owning a ticket")),(0,o.kt)("p",null,"The storage has to be modified. Collections are going to come in handy for the modification of the storage"),(0,o.kt)("h2",{id:"ligo-prerequisites-collections"},"LIGO prerequisites: collections"),(0,o.kt)("h3",{id:"lists"},"Lists"),(0,o.kt)("p",null,"Lists are ",(0,o.kt)("strong",{parentName:"p"},"linear collections of elements of the same type"),".\nLinear means that, in order to reach an element in a list,\nall the elements before have to be browsed (sequential access).\nElements can be repeated, as only their order in the collection matters.\nThe first element is called the head,\nand the sub-list after the head is called the tail."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"\ud83d\udca1 Lists are needed for example when returning operations from a smart contract's main function.")),(0,o.kt)("h4",{id:"defining-lists"},"Defining Lists"),(0,o.kt)("p",null,"To define an empty list, and a list with values:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const empty_list : list (int) = list [] // Or nil\nconst my_list : list (int) = list [1; 2; 2]\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"You can also use ",(0,o.kt)("inlineCode",{parentName:"p"},"nil")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"list []"))),(0,o.kt)("h4",{id:"adding-to-lists"},"Adding to Lists"),(0,o.kt)("p",null,"You can add elements to an existing list using the cons operator ",(0,o.kt)("inlineCode",{parentName:"p"},"#")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"cons(<value>, <list>)"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const larger_list : list (int) = 5 # my_list // [5; 1; 2; 2]\nconst larger_list_bis : list (int) = cons(5, my_list) // [5; 1; 2; 2]\n")),(0,o.kt)("h4",{id:"accessing-list-element"},"Accessing list element"),(0,o.kt)("p",null,"You cannot access element directly in list,\nbut you can access the first element,\nthe head or the rest of the list, the tail.\nThe two function to access those are ",(0,o.kt)("inlineCode",{parentName:"p"},"List.head_opt")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"List.tail_opt"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const head : option (int) = List.head_opt (my_list) // 1\nconst tail : option (list(int)) = List.tail_opt (my_list) // [2;2]\n")),(0,o.kt)("h3",{id:"sets"},"Sets"),(0,o.kt)("p",null,"Sets are ",(0,o.kt)("strong",{parentName:"p"},"unordered collections of values of the same type"),",\nlike lists are ordered collections.\nLike the mathematical sets and lists,\nsets can be empty and, if not,\nelements of sets in LIGO are unique,\nwhereas they can be repeated in a list."),(0,o.kt)("h4",{id:"defining-sets"},"Defining Sets"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const empty_set : set (int) = set []\nconst my_set : set (int) = set [3; 2; 2; 1]\n")),(0,o.kt)("h4",{id:"sets-tools"},"Sets tools"),(0,o.kt)("p",null,"You can test membership with the contains operator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const contains_3 : bool = my_set contains 3\n")),(0,o.kt)("p",null,"You can get the size of a set using the Set.size operator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const cardinal : nat = Set.size (my_set)\n")),(0,o.kt)("p",null,"To update a set:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const larger_set  : set (int) = Set.add (4, my_set)\nconst smaller_set : set (int) = Set.remove (3, my_set)\n")),(0,o.kt)("h3",{id:"maps"},"Maps"),(0,o.kt)("p",null,"Maps are a data structure which associates a value to a key, thus creating a key-value binding. All keys have the same type and all values have the same type.\nAn additional requirement is that the type of the keys must be comparable."),(0,o.kt)("h4",{id:"defining-a-map"},"Defining a Map"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'type balances is map (string, nat)\n\nconst empty : balances = map []\n\nconst user_balances : balances =\n    map [\n        "tim" -> 5n;\n        "mark" -> 0n\n    ]\n')),(0,o.kt)("h4",{id:"accessing-map-bindings"},"Accessing Map Bindings"),(0,o.kt)("p",null,"Use the postfix [] operator to read a value of the map:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const my_balance : option (nat) = user_balances ["tim"]\n')),(0,o.kt)("h4",{id:"updating-a-map"},"Updating a Map"),(0,o.kt)("p",null,"You can add or modify a value using the usual assignment syntax ",(0,o.kt)("inlineCode",{parentName:"p"},":=")," :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'user_balances ["tim"] := 2n\nuser_balances ["New User"] := 24n\n')),(0,o.kt)("p",null,"A key-value can be removed from the mapping as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'remove "tim" from map user_balances\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Maps load their entries into the environment,\nwhich is fine for small maps,\nbut for maps holding millions of entries,\nthe cost of loading such map would be too expensive.\nFor this we use ",(0,o.kt)("inlineCode",{parentName:"p"},"big_maps"),". Their syntax is the same as for regular maps.")),(0,o.kt)("h2",{id:"modifying-the-storage-1"},"Modifying the storage"),(0,o.kt)("p",null,"Thanks to these collections, the second entrypoint of the Raffle smart contract can be implemented.\nA list of participants must be kept, as well as the ticket/owner pair."),(0,o.kt)("p",null,"Two new pieces of information will be stored in the contract storage."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"What collection should be used for:"),(0,o.kt)("ol",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ol"},"the participants (who can only buy one ticket)?"),(0,o.kt)("li",{parentName:"ol"},"the tickets and their owner?"))),(0,o.kt)("p",null,"For the first point, two collections could be used: a list and a set.\nSince the participants can only buy one ticket, a set is the right choice (since each element cannot appear twice)."),(0,o.kt)("p",null,"For the second point, each ticket should be mapped to its owner. The number of participants is not limited:\nthere might be millions of them. So, a big map seems the right choice."),(0,o.kt)("p",null,"The set of participants should a set of addresses, while the big map should map a ticket id (a nat) to an address.\nThe new storage is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type storage is record [\n    admin : address;\n    close_date : timestamp;\n    jackpot : tez;\n    description : string;\n    raffle_is_open : bool;\n    players : set (address);\n    sold_tickets : big_map (nat, address);\n  ]\n")),(0,o.kt)("h2",{id:"adding-the-buyticket-entrypoint"},"Adding the BuyTicket Entrypoint"),(0,o.kt)("p",null,"The smart contract needs to expose another entrypoint.\nThe method is the same that has been detailed for the first entrypoint:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Defining the type parameter. This type should be ",(0,o.kt)("inlineCode",{parentName:"li"},"unit"),", since the buyer does not get to choose the ticket id:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type buyTicketParameter is unit\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Adding the entrypoint in the variant:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type raffleEntrypoints is\nOpenRaffle of openRaffleParameter\n| BuyTicket of buyTicketParameter\n")),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"Handling the new entrypoint in the control flow:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function main (const action : raffleEntrypoints; const store : storage): returnType is\nblock {\n    const return : returnType = case action of\n    OpenRaffle (param) -> open_raffle (param.0, param.1, param.2, store)\n    | BuyTicket (param) -> buy_ticket(param, store)\n    end;\n} with return\n")),(0,o.kt)("h2",{id:"implementing-the-buyticket-logic"},"Implementing the BuyTicket logic"),(0,o.kt)("p",null,"The last step is to implement the logic of this entrypoint.\nJust as for the first entrypoint, this logic will be implemented in a function, buy_ticket:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"  function buy_ticket (const param: unit; const store : storage) : returnType is\n    block { skip } with ((nil : list (operation)), store)\n")),(0,o.kt)("p",null,"Two pieces of information have to be checked:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"is the buyer sending enough funds?"),(0,o.kt)("li",{parentName:"ol"},"has the buyer not already bought a ticket?")),(0,o.kt)("p",null,"For the first point, this is the same check that is done for the first entrypoint.\nChecking if an address is calling the entrypoint for the first time (= a buyer cannot buy more than one ticket) means\nchecking if the calling address is already in the players ",(0,o.kt)("inlineCode",{parentName:"p"},"set"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function buy_ticket (const param: unit; const store : storage) : returnType is\n  block {\n    if store.raffle_is_open then {\n      const ticket_price : tez = 1tez;\n      const current_player : address = Tezos.sender;\n      if Tezos.amount = ticket_price then failwith("The sender does not own enough tz to buy a ticket.")\n      else {\n        if store.players contains current_player then failwith("Each player can participate only once.")\n        else {\n            skip\n        }\n      }\n    } else {\n      failwith("The raffle is closed.")\n    }\n  } with ((nil : list (operation)), store)\n')),(0,o.kt)("p",null,"Once these two checks have been performed, the buyer can receive a ticket. To do that, the entrypoint needs to:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"register the address as a participant: the address must be added into the players set from the storage."),(0,o.kt)("li",{parentName:"ol"},"create a ticket id. Since each participant can only buy ticket, the size of the players set give the new ticket id."),(0,o.kt)("li",{parentName:"ol"},"associate the ticket with its owner: the new ticket id will map to the buyer in the sold_tickets big_map.")),(0,o.kt)("p",null,"These three steps use the methods described in the collections section."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function buy_ticket (const param: unit; const store : storage) : returnType is\n  block {\n    if store.raffle_is_open then {\n      const ticket_price : tez = 1tez;\n      const current_player : address = Tezos.sender;\n      if Tezos.amount = ticket_price then failwith("The sender does not own enough tz to buy a ticket.")\n      else {\n        if store.players contains current_player then failwith("Each player can participate only once.")\n        else {\n          const ticket_id : nat = Set.size(store.players);\n          store.players := Set.add(current_player, store.players);\n          store.sold_tickets[ticket_id] := current_player;\n        }\n      }\n    } else {\n      failwith("The raffle is closed.")\n    }\n  } with ((nil : list (operation)), store)\n')),(0,o.kt)("p",null,"The contract now is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'type openRaffleParameter is tez * timestamp * option(string)\ntype buyTicketParameter is unit\n\ntype raffleEntrypoints is\nOpenRaffle of openRaffleParameter\n| BuyTicket of buyTicketParameter\n\ntype storage is record [\n    admin : address;\n    close_date : timestamp;\n    jackpot : tez;\n    description : string;\n    raffle_is_open : bool;\n    players : set (address);\n    sold_tickets : big_map (nat, address);\n    ]\n\ntype returnType is list (operation) * storage\n\nfunction open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option (string); const store : storage) : returnType is\n  block {\n    if Tezos.source =/= store.admin\n    then failwith ("Administrator not recognized.")\n    else {\n      if not store.raffle_is_open then {\n        if Tezos.amount < jackpot_amount then failwith ("The administrator does not own enough tz.")\n        else {\n          const today : timestamp = Tezos.now;\n          const seven_day : int = 7 * 86400;\n          const in_7_day : timestamp = today + seven_day;\n          const is_close_date_not_valid : bool = close_date < in_7_day;\n          if is_close_date_not_valid then failwith("The raffle must remain open for at least 7 days.")\n          else {\n            patch store with record [\n            jackpot = jackpot_amount;\n            close_date = close_date;\n            raffle_is_open = True;\n            ];\n\n            case description of\n              Some(d) -> patch store with record [description=d]\n            | None -> {skip}\n            end\n          }\n        }\n      }\n      else {\n        failwith ("A raffle is already open.")\n      }\n    }\n  } with ((nil : list (operation)), store)\n\nfunction buy_ticket (const param: unit; const store : storage) : returnType is\n  block {\n    if store.raffle_is_open then {\n      const ticket_price : tez = 1tez;\n      const current_player : address = Tezos.sender;\n      if Tezos.amount = ticket_price then failwith("The sender does not own enough tz to buy a ticket.")\n      else {\n        if store.players contains current_player then failwith("Each player can participate only once.")\n        else {\n          const ticket_id : nat = Set.size(store.players);\n          store.players := Set.add(current_player, store.players);\n          store.sold_tickets[ticket_id] := current_player;\n        }\n      }\n    } else {\n      failwith("The raffle is closed.")\n    }\n  } with ((nil : list (operation)), store)\n\nfunction main (const action : raffleEntrypoints; const store : storage): returnType is\nblock {\n    const return : returnType = case action of\n    OpenRaffle (param) -> open_raffle (param.0, param.1, param.2, store)\n    | BuyTicket (param) -> buy_ticket(param, store)\n    end;\n} with return\n')),(0,o.kt)("h1",{id:"smart-contract-development-close-raffle-entrypoint"},"Smart Contract development: Close Raffle Entrypoint"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"LIGO prerequisites in this part: you will learn how to use transactions, be warned about some limitations of the language\nand manipulate a little more collections.\nIn addition, this entrypoint sums up a lof of what has been done before:"),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"transactions"),(0,o.kt)("li",{parentName:"ul"},"randomness"))),(0,o.kt)("p",null,"The last step is to close the raffle, pick a winner and send him the reward.\nThis last entrypoint will show how to send a transaction from the contract and some collections manipulations"),(0,o.kt)("p",null,"5 steps are required:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Check that the calling address is the administrator"),(0,o.kt)("li",{parentName:"ol"},"Check that the closing date has been reached, and that the raffle is still open"),(0,o.kt)("li",{parentName:"ol"},"Pick a winner"),(0,o.kt)("li",{parentName:"ol"},"Send the reward to the winner"),(0,o.kt)("li",{parentName:"ol"},"Reset the storage")),(0,o.kt)("p",null,"New pieces of information won't be stored: the storage is not expected to be modified.\nHowever, the third step raises a problem: how should the winner be picked ?"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"the administrator chooses the winner when calling this entrypoint:\nparticipants are likely not to buy a ticket since the administrator can choose himself as a winner"),(0,o.kt)("li",{parentName:"ol"},"the winner is randomly chosen when calling this entrypoint"),(0,o.kt)("li",{parentName:"ol"},"the winner is chosen at the beginning by the administrator, but this piece of information is only revealed at the end of the raffle.")),(0,o.kt)("h2",{id:"ligo-prerequisites-transactions"},"LIGO prerequisites: Transactions"),(0,o.kt)("p",null,"You can transfer tez to an account, and invoke a function of another smart contract.\nFor this, use :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"Tezos.transaction (<parameter>, <mutez>, <contract>);\n")),(0,o.kt)("p",null,"where :"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"parameter")," is the entrypoint of another contract,\nor use ",(0,o.kt)("inlineCode",{parentName:"li"},"unit")," if you are transferring to a wallet address,"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"mutez")," is the amount to transfer,"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"contract")," is the contract interface of the targeted contract.\nIt can be retrieved (with ",(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.get_contract_opt")," built-in function) from the address of the other contract or the wallet.")),(0,o.kt)("p",null,"Here is an example of retrieving the contract interface from the ",(0,o.kt)("em",{parentName:"p"},"winner")," ",(0,o.kt)("inlineCode",{parentName:"p"},"address"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const receiver : contract (unit) = \n    case (Tezos.get_contract_opt (winner) : option (contract (unit))) of\n          Some (c) -> c\n        | None -> (failwith ("winner contract not found.") : contract (unit))\n        end;\n\nconst op : operation = Tezos.transaction(unit, store.jackpot, receiver);\n')),(0,o.kt)("p",null,"Notice that the ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_opt")," built-in function call returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"option (contract (unit))"),"; thus allowing to verify that the ",(0,o.kt)("em",{parentName:"p"},"winner")," address is valid."),(0,o.kt)("h2",{id:"about-randomness-in-smart-contracts"},"About randomness in smart contracts"),(0,o.kt)("p",null,"The second option is not easily implemented in smart contracts. In any classical programming language (Python, C, Java...),\na ",(0,o.kt)("strong",{parentName:"p"},"random")," function is directly usable from the standard API. With smart contracts, it is not possible."),(0,o.kt)("p",null,"Indeed, each smart contract execution has to be verified by any node in the network.\nHowever, how could this execution be verified if there is a random variable (that would change every time)?"),(0,o.kt)("p",null,"It might seem to be a good idea to use blockchain events (transaction hash, block timestamp...) as source of randomness.\nHowever, in the end, bakers which create blocks could use this to their advantage."),(0,o.kt)("p",null,"The only solution seems to use an external source of randomness or a secure cryptographic scheme.\nThis topic goes well beyond this course.\nFor educational purpose, we will at first hardcode a ticket id winner.\nThen, the smart contract will be refactored, using the Bytes and Crypto modules."),(0,o.kt)("h2",{id:"adding-the-closeraffle-entrypoint"},"Adding the CloseRaffle entrypoint"),(0,o.kt)("p",null,"The smart contract needs to expose this last entrypoint.\nThe method is the same that has been detailed for the first and second entrypoint:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Defining the type parameter. This type should be unit, since the administrator just has to close the raffle without any other piece of information:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type closeRaffleParameter is unit\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Adding the entrypoint in the variant:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type raffleEntrypoints is\nOpenRaffle of openRaffleParameter\n| BuyTicket of buyTicketParameter\n| CloseRaffle of closeRaffleParameter\n")),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"Handling the new entrypoint in the control flow:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function main (const action : raffleEntrypoints; const store : storage): returnType is\nblock {\n    const return : returnType = case action of\n    OpenRaffle (param) -> open_raffle (param.0, param.1, param.2, store)\n    | BuyTicket (param) -> buy_ticket(param, store)\n    | CloseRaffle (param) -> close_raffle (param, store)\n    end;\n} with return\n")),(0,o.kt)("h2",{id:"implementing-the-closeraffle-logic"},"Implementing the CloseRaffle logic"),(0,o.kt)("p",null,"Let's create an empty function for this entrypoint:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"  function close_raffle (const param: unit; const store : storage) : returnType is\n    block { const operations : list(operation) = nil; } with (operations, store)\n")),(0,o.kt)("p",null,"There is a slight difference with this entrypoint function: it has to return an operation.\nAs a result, the list of operations won't be empty and will be filled with one operation from within the function block."),(0,o.kt)("p",null,"The usual checks have to be implemented:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"only the administrator can close the raffle"),(0,o.kt)("li",{parentName:"ol"},"the closing date must have been reached"),(0,o.kt)("li",{parentName:"ol"},"the raffle must be open")),(0,o.kt)("p",null,"The winner will be picked thanks to a hardcoded value.\nHowever, even if there are only two participants, the raffle must have a winner.\nSo, the number of participants must be known, so that the winning id does match an id ticket. For this, a modulo will be used:\n",(0,o.kt)("inlineCode",{parentName:"p"},"hardcoded_number mod number_of_participants"),"\nOf course, LIGO offers all the arithmetic operations (addition, subtraction, multiplication, division, mod). It won't be detailed here, since it exactly the same as other languages."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function close_raffle (const param : unit; const store : storage) : returnType is\n  block {\n    const operations : list(operation) = nil;\n    if Tezos.source =/= store.admin then failwith("administrator not recognized.")\n    else {\n      if store.raffle_is_open then {\n        if Tezos.now < store.close_date then failwith("The raffle must remain open for at least 7 days.")\n        else{\n          const number_of_players : nat = Set.size(store.players);\n          const random_number : nat = 467n; // hardcoded number\n          const winning_ticket_id : nat = random_number mod number_of_players; // modulo expression\n        }\n      } else {\n        failwith("The raffle is closed.")\n      }\n    }\n  } with (operations, store)\n')),(0,o.kt)("p",null,"The winning ticket is now chosen. The next step is to find its owner from the ",(0,o.kt)("inlineCode",{parentName:"p"},"sold_tickets big_map"),".\nSince a key might not exist in a big map, fetching the value always return an option.\nThis option is handled with a pattern matching as below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function close_raffle (const param : unit; const store : storage) : returnType is\n  block {\n    const operations : list(operation) = nil;\n    if Tezos.source =/= store.admin then failwith("administrator not recognized.")\n    else {\n      if store.raffle_is_open then {\n        if Tezos.now < store.close_date then failwith("The raffle must remain open for at least 7 days.")\n        else{\n          const number_of_players : nat = Set.size(store.players);\n          const random_number : nat = 467n;\n          const winning_ticket_id : nat = random_number mod number_of_players;\n\n          const winner : address = \n          case (store.sold_tickets[winning_ticket_id]) of\n            Some (a) -> a\n          | None -> (failwith ("winner address not found") : address)\n          end;\n        }\n      } else {\n        failwith("The raffle is closed.")\n      }\n    }\n  } with (operations, store)\n')),(0,o.kt)("p",null,"The winner has been found and now has to be rewarded.\nFirst, we need to check that this address does exist, then create a transaction which will be added to the operations list:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function close_raffle (const param : unit; const store : storage) : returnType is\n  block {\n    const operations : list(operation) = nil;\n    if Tezos.source =/= store.admin then failwith("administrator not recognized.")\n    else {\n      if store.raffle_is_open then {\n        if Tezos.now < store.close_date then failwith("The raffle must remain open for at least 7 days.")\n        else{\n          const number_of_players : nat = Set.size(store.players);\n          const random_number : nat = 467n;\n          const winning_ticket_id : nat = random_number mod number_of_players;\n\n          const winner : address = \n          case (store.sold_tickets[winning_ticket_id]) of\n            Some (a) -> a\n          | None -> (failwith ("winner address not found") : address)\n          end;\n\n          const receiver : contract (unit) =\n          case (Tezos.get_contract_opt (winner) : option (contract (unit))) of\n            Some (c) -> c\n          | None -> (failwith ("winner contract not found.") : contract (unit))\n          end;\n\n          const op : operation = Tezos.transaction(unit, store.jackpot, receiver);\n          const operations : list(operation) = list [ op; ];\n        }\n      } else {\n        failwith("The raffle is closed.")\n      }\n    }\n  } with (operations, store)\n')),(0,o.kt)("p",null,"The operations variable is not empty anymore: this entrypoint does return a transaction, that will be sent by the smart contract."),(0,o.kt)("p",null,"Finally, the storage need to be reset. All the fields will be filled with empty values:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function close_raffle (const param : unit; const store : storage) : returnType is\n  block {\n    const operations : list(operation) = nil;\n    if Tezos.source =/= store.admin then failwith("administrator not recognized.")\n    else {\n      if store.raffle_is_open then {\n        if Tezos.now < store.close_date then failwith("The raffle must remain open for at least 7 days.")\n        else{\n          const number_of_players : nat = Set.size(store.players);\n          const random_number : nat = 467n;\n          const winning_ticket_id : nat = random_number mod number_of_players;\n\n          const winner : address = \n          case (store.sold_tickets[winning_ticket_id]) of\n            Some (a) -> a\n          | None -> (failwith ("winner address not found") : address)\n          end;\n\n          const receiver : contract (unit) =\n          case (Tezos.get_contract_opt (winner) : option (contract (unit))) of\n            Some (c) -> c\n          | None -> (failwith ("winner contract not found.") : contract (unit))\n          end;\n\n          const op : operation = Tezos.transaction(unit, store.jackpot, receiver);\n          const operations : list(operation) = list [ op; ];\n          \n          patch store with record [\n          jackpot = 0tez;\n          close_date = (0 : timestamp);\n          description = ("raffle is currently closed" : string);\n          raffle_is_open = False;\n          players = (set[] : set(address));\n          sold_tickets = (big_map[] : big_map (nat, address));\n          ];\n        }\n      } else {\n        failwith("The raffle is closed.")\n      }\n    }\n  } with (operations, store)\n')),(0,o.kt)("h1",{id:"smart-contract-refactoring"},"Smart contract refactoring"),(0,o.kt)("p",null,"Just as any other project, smart contracts will need refactoring during their development.\nIn this part, the way the winner is chosen will be refactored. "),(0,o.kt)("p",null,"Everyone, by reading the code, knows that the winning ticket is ",(0,o.kt)("inlineCode",{parentName:"p"},"407 mod Set.size(store.players)"),".\nBy tampering with the number of bought tickets, it is easy for everyone to get the winning ticket.\nIn this part, we will make it harder to guess the winning ticker number.\nHowever, ",(0,o.kt)("strong",{parentName:"p"},"the method that will be used is not security compliant"),".\nThis refactoring is meant for educational purposes: to show some advanced features of LIGO. Do NOT use for any other usage."),(0,o.kt)("p",null,"This part is an opportunity to put the emphasis on two modules: ",(0,o.kt)("inlineCode",{parentName:"p"},"Bytes")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Crypto"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Bytes")," module handles binary format for serialization:\nconvert Michelson structures to a binary format (and the reverse), concatenate two bytes...\nYou can find a full reference ",(0,o.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/reference/bytes-reference/"},"here")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Crypto")," module performs a few basic operations: hashing and signature verification.\nYou can find a full reference ",(0,o.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/reference/crypto-reference"},"here"),"."),(0,o.kt)("h2",{id:"winner-selection-scheme"},"Winner selection scheme"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The administrator will choose a large random number and keeps it to himself. "),(0,o.kt)("li",{parentName:"ol"},"He hashes it and sends the hash when calling the OpenRaffle entrypoint."),(0,o.kt)("li",{parentName:"ol"},"This hash is saved into the storage."),(0,o.kt)("li",{parentName:"ol"},"The administrator reveals his secret random large number when calling the CloseRaffle entrypoint."),(0,o.kt)("li",{parentName:"ol"},"The smart contract hashes this number and checks that it matches the storage hash.\nIf it does, it uses this number to pick the winner just as before.\n")),(0,o.kt)("p",null,"As warned above, this method is still rife with loopholes: "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the administrator knows the secret number and can tamper with the number of bought ticket in order to get the winning one"),(0,o.kt)("li",{parentName:"ul"},"everyone can try to bruteforce the hash in order to find what number yielded this hash. This method just makes it a little harder to guess the number.")),(0,o.kt)("h2",{id:"refactoring-the-openraffle-entrypoint"},"Refactoring the OpenRaffle entrypoint"),(0,o.kt)("p",null,"The OpenRaffle entrypoint expects a new input: the number hash, that should be saved into the storage.\nBoth the storage and entrypoint have to be modified.\nThe method is very similar to what has been done before:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Refactoring the storage: it must store a hash. According to the LIGO documentation, a hash has a ",(0,o.kt)("inlineCode",{parentName:"li"},"bytes")," type:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type storage is record [\n    admin : address;\n    close_date : timestamp;\n    jackpot : tez;\n    description : string;\n    players : set (address);\n    sold_tickets : map (nat, address);\n    raffle_is_open : bool;\n    winning_ticket_number_hash : bytes;\n]\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Adding the new input in the openRaffleParameter. The bytes type is added in the tuple:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type openRaffleParameter is tez * timestamp * option(string) * bytes\n")),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"Updating the entrypoint function header:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option (string); const winning_ticket_number_hash : bytes; const store : storage) : returnType is\n\n")),(0,o.kt)("ol",{start:4},(0,o.kt)("li",{parentName:"ol"},"Refactoring the entrypoint logic. For this change, the only thing to do is to save the hash into the storage:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option (string); const winning_ticket_number_hash : bytes; const store : storage) : returnType is\n  block {\n    if Tezos.source =/= store.admin then failwith("Administrator not recognized.")\n    else {\n      if not store.raffle_is_open then {\n        if Tezos.amount < jackpot_amount then failwith("The administrator does not own enough tz.")\n        else{\n        const today : timestamp = Tezos.now;\n        const seven_day : int = 7 * 86400;\n        const in_7_day : timestamp = today + seven_day;\n        const is_close_date_not_valid : bool = close_date < in_7_day;\n        if is_close_date_not_valid then failwith("The raffle must remain open for at least 7 days.")\n        else {\n          patch store with record [\n          jackpot = jackpot_amount;\n          close_date = close_date;\n          raffle_is_open = True;\n          winning_ticket_number_hash = winning_ticket_number_hash; // the hash is saved into the storage\n          ];\n\n          case description of\n            Some(d) -> patch store with record [description=d]\n          | None -> {skip}\n          end\n        }\n      }\n    } else {\n        failwith("A raffle is already open.")\n    }\n  }\n} with ((nil : list (operation)), store)\n')),(0,o.kt)("ol",{start:5},(0,o.kt)("li",{parentName:"ol"},"The new input has to be processed in the control flow:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function main (const action : raffleEntrypoints; const store : storage): returnType is\nblock { \n    const return : returnType = case action of \n      OpenRaffle (param) -> open_raffle (param.0, param.1, param.2, param.3, store)\n    | BuyTicket (param) -> buy_ticket(param, store)\n    | CloseRaffle (param) -> close_raffle (param, store)\n    end;\n } with return\n")),(0,o.kt)("p",null,"The smart contract now compiles:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"$ ligo compile-contract raffle.ligo main\n")),(0,o.kt)("h2",{id:"refactoring-the-closeraffle-entrypoint"},"Refactoring the CloseRaffle entrypoint"),(0,o.kt)("p",null,"The method is the same here.\nThe step-by-step changes won't be detailed: try to do this refactoring on your own.\nThe ligo documentation will tell you how to hash a number and compare it."),(0,o.kt)("p",null,"Once you're done with your smart contract refactoring, you can compare it with our suggested version:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'type openRaffleParameter is tez * timestamp * option(string) * bytes\ntype buyTicketParameter is unit\ntype closeRaffleParameter is nat\n\ntype raffleEntrypoints is\nOpenRaffle of openRaffleParameter\n| BuyTicket of buyTicketParameter\n| CloseRaffle of closeRaffleParameter\n\ntype storage is record [\n    admin : address;\n    close_date : timestamp;\n    jackpot : tez;\n    description : string;\n    players : set (address);\n    sold_tickets : map (nat, address);\n    raffle_is_open : bool;\n    winning_ticket_number_hash : bytes;\n  ]\n\ntype returnType is list (operation) * storage\n\nfunction open_raffle (const jackpot_amount : tez; const close_date : timestamp; const description : option (string); const winning_ticket_number_hash : bytes; const store : storage) : returnType is\n  block {\n    if Tezos.source =/= store.admin\n    then failwith ("Administrator not recognized.")\n    else {\n      if not store.raffle_is_open then {\n        if Tezos.amount < jackpot_amount then failwith ("The administrator does not own enough tz.")\n        else {\n          const today : timestamp = Tezos.now;\n          const seven_day : int = 7 * 86400;\n          const in_7_day : timestamp = today + seven_day;\n          const is_close_date_not_valid : bool = close_date < in_7_day;\n          if is_close_date_not_valid then failwith("The raffle must remain open for at least 7 days.")\n          else {\n            patch store with record [\n            jackpot = jackpot_amount;\n            close_date = close_date;\n            raffle_is_open = True;\n            winning_ticket_number_hash = winning_ticket_number_hash; // the hash is saved into the storage\n            ];\n\n            case description of\n              Some(d) -> patch store with record [description=d]\n            | None -> {skip}\n            end\n          }\n        }\n      }\n      else {\n        failwith ("A raffle is already open.")\n      }\n    }\n  } with ((nil : list (operation)), store)\n\nfunction buy_ticket (const param: unit; const store : storage) : returnType is\n  block {\n    if store.raffle_is_open then {\n      const ticket_price : tez = 1tez;\n      const current_player : address = Tezos.sender;\n      if Tezos.amount = ticket_price then failwith("The sender does not own enough tz to buy a ticket.")\n      else {\n        if store.players contains current_player then failwith("Each player can participate only once.")\n        else {\n          const ticket_id : nat = Set.size(store.players);\n          store.players := Set.add(current_player, store.players);\n          store.sold_tickets[ticket_id] := current_player;\n        }\n      }\n    } else {\n      failwith("The raffle is closed.")\n    }\n  } with ((nil : list (operation)), store)\n\nfunction close_raffle (const winning_ticket_number : nat; const store : storage) : returnType is\n  block {\n    const operations : list(operation) = nil;\n    if Tezos.source =/= store.admin then failwith("administrator not recognized.")\n    else {\n      if store.raffle_is_open then {\n        if Tezos.now < store.close_date then failwith("The raffle must remain open for at least 7 days.")\n        else{\n          const winning_ticket_number_bytes : bytes = Bytes.pack(winning_ticket_number);\n          const winning_ticket_number_hash : bytes = Crypto.sha256(winning_ticket_number_bytes);\n          if winning_ticket_number_hash =/= store.winning_ticket_number_hash then failwith("the hash does not match the hash of the winning ticket.")\n          else{\n            const number_of_players : nat = Set.size(store.players);\n            const winning_ticket_id : nat = winning_ticket_number mod number_of_players;\n\n            const winner : address = \n            case (store.sold_tickets[winning_ticket_id]) of\n                Some (a) -> a\n            | None -> (failwith ("winner address not found") : address)\n            end;\n\n            const receiver : contract (unit) =\n            case (Tezos.get_contract_opt (winner) : option (contract (unit))) of\n                Some (c) -> c\n            | None -> (failwith ("winner contract not found.") : contract (unit))\n            end;\n\n            const op : operation = Tezos.transaction(unit, store.jackpot, receiver);\n            const operations : list(operation) = list [ op; ];\n\n            patch store with record [\n            jackpot = 0tez;\n            close_date = (0 : timestamp);\n            description = ("raffle is currently closed" : string);\n            raffle_is_open = False;\n            players = (set[] : set(address));\n            sold_tickets = (map[] : map (nat, address));\n            ];\n          }\n        }\n      } else {\n        failwith("The raffle is closed.")\n      }\n    }\n  } with (operations, store)\n\nfunction main (const action : raffleEntrypoints; const store : storage): returnType is\nblock {\n    const return : returnType = case action of\n    OpenRaffle (param) -> open_raffle (param.0, param.1, param.2, param.3, store)\n    | BuyTicket (param) -> buy_ticket(param, store)\n    | CloseRaffle (param) -> close_raffle (param, store)\n    end;\n} with return\n\n')),(0,o.kt)("hr",null),(0,o.kt)("h1",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"Ligo is meant for smart contract development and always yields Michelson code.\nThe method for developing such smart contracts is pretty much always the same,\nand follows an order very close to the Michelson smart contract structure:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"the ",(0,o.kt)("strong",{parentName:"li"},"parameter")," (or entrypoints): the entrypoints are defined into a variant, a type is defined for the input entrypoints, "),(0,o.kt)("li",{parentName:"ol"},"the ",(0,o.kt)("strong",{parentName:"li"},"storage"),": the storage is defined as a type. Usually, it is a record."),(0,o.kt)("li",{parentName:"ol"},"the ",(0,o.kt)("strong",{parentName:"li"},"code"),": the main function dispatches the actions with a pattern matching. The logic for each entrypoint is implemented in a function")),(0,o.kt)("p",null,"There has to be a ",(0,o.kt)("strong",{parentName:"p"},"main")," function, which dispatches the actions of the smart contract."),(0,o.kt)("p",null,"LIGO syntax was designed to help developers to build smart contracts by providing them with a syntax familiar to them:\nthe main difference from other languages been the way the code is built, and a few technical limitations due to the particularities of blockchain (randomness for instance)."),(0,o.kt)("p",null,"LIGO is only a part of the tools that make the smart contract development experience easier for developers.\nAnother part is unit testing, and it will be introduced later in this module."),(0,o.kt)("p",null,"`"))}d.isMDXComponent=!0},9784:function(e,t,n){"use strict";t.Z=n.p+"assets/images/main_function-def6ca332b38507cc42b237cc24c24fc.svg"}}]);