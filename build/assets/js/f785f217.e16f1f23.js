(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[6123],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(n),d=i,h=m["".concat(l,".").concat(d)]||m[d]||u[d]||r;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3539:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},metadata:function(){return s},toc:function(){return l},default:function(){return p}});var a=n(2122),i=n(9756),r=(n(7294),n(3905)),o={id:"smart-contracts",title:"Smart Contracts",authors:"Frank Hillard"},s={unversionedId:"michelson/smart-contracts",id:"michelson/smart-contracts",isDocsHomePage:!1,title:"Smart Contracts",description:"Smart contracts in Michelson",source:"@site/docs/michelson/smart-contracts.md",sourceDirName:"michelson",slug:"/michelson/smart-contracts",permalink:"/michelson/smart-contracts",editUrl:"https://github.com/octo-technology/OpenTezos/tree/main/docs/michelson/smart-contracts.md",version:"current",lastUpdatedBy:"Frank Hillard",lastUpdatedAt:1621504851,formattedLastUpdatedAt:"5/20/2021",frontMatter:{id:"smart-contracts",title:"Smart Contracts",authors:"Frank Hillard"},sidebar:"docs",previous:{title:"Introduction",permalink:"/michelson"},next:{title:"Tutorial",permalink:"/michelson/tutorial"}},l=[{value:"Smart contracts in Michelson",id:"smart-contracts-in-michelson",children:[{value:"Entrypoint",id:"entrypoint",children:[]},{value:"Storage",id:"storage",children:[]},{value:"Code",id:"code",children:[]}]},{value:"Michelson overview",id:"michelson-overview",children:[{value:"Stack-based language",id:"stack-based-language",children:[]},{value:"Static typing",id:"static-typing",children:[]},{value:"Atomic computation",id:"atomic-computation",children:[]},{value:"Gas model",id:"gas-model",children:[]}]},{value:"Deployment - Address and balance",id:"deployment---address-and-balance",children:[]},{value:"Invocation and transaction return (list of operations, storage)",id:"invocation-and-transaction-return-list-of-operations-storage",children:[]},{value:"Explicit failure",id:"explicit-failure",children:[]}],c={toc:l};function p(e){var t=e.components,o=(0,i.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"smart-contracts-in-michelson"},"Smart contracts in Michelson"),(0,r.kt)("p",null,"Michelson is a domain-specific language and is designed for implementing smart contracts. Tezos smart contracts contain three main pieces of information:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("strong",{parentName:"li"},"parameter")," of the smart contract which describes the possible invocations of the smart contract (often called ",(0,r.kt)("strong",{parentName:"li"},"entrypoints"),") and related arguments."),(0,r.kt)("li",{parentName:"ul"},"the type definition of the persistent data structure associated with the smart contract (referred to as ",(0,r.kt)("strong",{parentName:"li"},"storage"),")."),(0,r.kt)("li",{parentName:"ul"},"a sequence of instructions to be executed when invoking the smart contract (this is the ",(0,r.kt)("strong",{parentName:"li"},"code")," of the smart contract).")),(0,r.kt)("p",null,"Basically, a smart contract is defined by those three pieces of information (parameter, storage, code) and an empty smart contract looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"parameter unit;\nstorage unit;\ncode { CDR ;\n       NIL operation ;\n       PAIR };\n")),(0,r.kt)("p",null,'These three instructions will be described later in the "invocation" sub-section of this chapter and in the "Instructions" section.'),(0,r.kt)("h3",{id:"entrypoint"},"Entrypoint"),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"parameter")," of the smart contract describes all possible invocations of the smart contract.\nAn entrypoint is an invocable function of the smart contract which takes arguments. These arguments are specific to the entrypoint."),(0,r.kt)("p",null,"Each entrypoint is composed of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the type definition of the expected argument of the entrypoint "),(0,r.kt)("li",{parentName:"ul"},"the annotation (name) of the entrypoint")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The following example is not meant to be understood yet but intends to illustrate the three parts of the smart contract. This example will be crystal clear after reading the ",(0,r.kt)("a",{parentName:"p",href:"/michelson/tutorial"},"tutorial")," section.")),(0,r.kt)("p",null,"The example below (Counter contract) shows a simple smart contract implementing a counter: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"{ parameter (or (or (nat %add) (nat %sub)) (unit %default)) ;\n  storage int ;\n  code { AMOUNT ; PUSH mutez 0 ; ASSERT_CMPEQ ; UNPAIR ;\n         IF_LEFT\n           { IF_LEFT { ADD } { SWAP ; SUB } }\n           { DROP ; DROP ; PUSH int 0 } ;\n         NIL operation ; PAIR } }\n")),(0,r.kt)("p",null,"Notice that in the Counter contract the parameter describing possible invocations is defined as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"(or (or (nat %add) (nat %sub)) (unit %default))\n")),(0,r.kt)("p",null,"The three possible invocations (add, sub, and default) are specified in a single logical structure composed of logical ",(0,r.kt)("em",{parentName:"p"},"or")," operators.\nSince ",(0,r.kt)("em",{parentName:"p"},"or")," is a two-operand operator, we need a nested ",(0,r.kt)("em",{parentName:"p"},"or")," structure to represent 3 or more elements."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(5292).Z})),(0,r.kt)("small",{className:"figure"},"FIGURE 1: Representation of the _or_ structure and how to specify the corresponding entrypoints (the identification of related entrypoints)"),(0,r.kt)("p",null,'We will delve into this more deeply in the code portion of the "union" section.'),(0,r.kt)("h3",{id:"storage"},"Storage"),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"storage")," is a persistent memory space associated with the smart contract when it is deployed. The data structure of the storage is defined in the smart contract during the deployment phase."),(0,r.kt)("p",null,"Notice that in the Counter contract (above) the type definition that describe the storage is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"  storage int ;\n")),(0,r.kt)("h3",{id:"code"},"Code"),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"code")," of the smart contract is a sequence of Michelson instructions separated by semi-colons ",(0,r.kt)("inlineCode",{parentName:"p"},";"),"."),(0,r.kt)("p",null,'We will delve into this more deeply in "instructions" and "tutorial" sections, but before that let\'s have a quick overview of the Michelson language.'),(0,r.kt)("h2",{id:"michelson-overview"},"Michelson overview"),(0,r.kt)("p",null,"The Michelson language is the reference language for Tezos smart contracts. It is a low-level ",(0,r.kt)("strong",{parentName:"p"},"stack-based")," language and is also a ",(0,r.kt)("strong",{parentName:"p"},"Turing-complete")," language. This means it has basic operations allowing to read/write/compare values in-memory, has infinite memory, and allows conditional operators (e.g. ",(0,r.kt)("em",{parentName:"p"},"if"),", ",(0,r.kt)("em",{parentName:"p"},"switch")," instructions)."),(0,r.kt)("p",null,"The Michelson language introduces data types for structuring data and instructions on these data types for manipulating data."),(0,r.kt)("h3",{id:"stack-based-language"},"Stack-based language"),(0,r.kt)("p",null,"Generally speaking, a ",(0,r.kt)("em",{parentName:"p"},"stack")," data structure is a linear collection of elements which can be added or removed respectively with the ",(0,r.kt)("inlineCode",{parentName:"p"},"PUSH")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"POP")," instruction. In the Michelson language, elements can be pushed to the top of the pile or removed from the top of the pile. This kind of stack is called LIFO (Last In First Out)."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(4563).Z})),(0,r.kt)("small",{className:"figure"},"FIGURE 2: Illustration of a stack"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/michelson/tutorial"},"Tutorial")," section describes basic stack manipulations allowed by the Michelson language."),(0,r.kt)("h3",{id:"static-typing"},"Static typing"),(0,r.kt)("p",null,"The Michelson language is a strongly typed language. It means that all data inserted into the stack must be typed and operators manipulating these data must respect the typing rules."),(0,r.kt)("p",null,"The Michelson language introduces primitive types for modelling data and composite types allowing for complex data structure definitions. It also introduces very specific types for smart contract modelling."),(0,r.kt)("p",null,"The Michelson language provides basic type support on numbers, sequence of characters, logical expressions, and timestamps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"nat")," represents a natural integer (e.g. 0, 3, 15)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"int")," represents a integer (e.g. -10, 2, 3)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"string"),' represents a sequence of characters (e.g. "Hello")'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool")," represents a boolean value (e.g. True, False)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bytes")," represents a sequence of bytes (octet)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"unit")," represents a non-specified type."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"timestamp"),' represents a duration (e.g. NOW, 1571659294, "2019-09-26T10:59:51Z"; i.e. a string following the RFC3339 standard)')),(0,r.kt)("p",null,"Michelson also provides composite types for grouping properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"set")," represents an unordered collection of elements. It preserves the uniqueness of elements inside the collection (e.g. { 2; 4; 5; 7})"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"list")," represents an ordered collection of elements of the same type (e.g. { 2; 4; 5; 3; 5 })"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"map"),' represents an associative array formed of key-value elements (e.g. { Elt "Hello" 1 }) '),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"big_map")," is another representation of an associative array but can handle larger amounts of data"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pair"),' represents a tuple of two elements (e.g. Pair "World" 1).'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"option")," is a predefined variant type that is used to express whether there is a value of some type or ",(0,r.kt)("em",{parentName:"li"},"none"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"or")," is a variant type that can handle elements of different types.")),(0,r.kt)("p",null,"Michelson also provides specific types for smart contract modelling:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"address"),' represents an identifier for a user account or a deployed smart contract (e.g. "tz1faswCTDciRzE4oJ9jn2Vm2dvjeyA9fUzU")'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"mutez")," represents the smallest quantity of the Tezos crypto-currency (1 tez = 1,000,000 mutez)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key"),' is a byte sequence representing a public key (e.g. "edpkuBknW28nW72KG6RoH..." )'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key_hash"),' represents a hashed key using a standard hashing function such as SHA512 (e.g. "tz1KqTpEZ7Yob7QbPE4Hy..."; i.e. a string in base58 encoded form)'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"signature"),' is a byte sequence representing a message signed by a public key (e.g. "spsig1PPUFZucuAQybs5w...)'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"chain_id"),' represents the network identifer (e.g. 0x7a06a770, "NetXynUjJNZm7wi")'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operation")," represents a transaction"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"contract")," represents a contract interface used for contract interaction")),(0,r.kt)("p",null,'The usage of these types is illustrated in the "Tutorial" and "Instructions" sections.'),(0,r.kt)("h3",{id:"atomic-computation"},"Atomic computation"),(0,r.kt)("p",null,"The Michelson language provides basic operations on these types:  "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"numbers: addition, subtraction, multiplication, euclidean division, comparison"),(0,r.kt)("li",{parentName:"ul"},"string: split, concatenation, comparison"),(0,r.kt)("li",{parentName:"ul"},"crypto: standard hash function"),(0,r.kt)("li",{parentName:"ul"},"collection: standard collection manipulation (create, insert, remove, access, modification) "),(0,r.kt)("li",{parentName:"ul"},"currency: standard operations on XTZ crypto-currency"),(0,r.kt)("li",{parentName:"ul"},"smart contract: contract interactions, transfer, invocation of smart contracts, delegation")),(0,r.kt)("p",null,'A description of some of these operators is provided in the "Tutorial" section.'),(0,r.kt)("p",null,'An exhaustive list of instructions for each type is described in the "Instructions" section.'),(0,r.kt)("p",null,"These instructions introduce basic programming concepts such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"conditional branching: The",(0,r.kt)("inlineCode",{parentName:"li"},"IF")," instruction family."),(0,r.kt)("li",{parentName:"ul"},"repetitive processing: ",(0,r.kt)("inlineCode",{parentName:"li"},"LOOP"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ITER"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"MAP")," instructions."),(0,r.kt)("li",{parentName:"ul"},'"Lambda" functions: ',(0,r.kt)("inlineCode",{parentName:"li"},"LAMBDA")," instruction."),(0,r.kt)("li",{parentName:"ul"},"structuring data: ",(0,r.kt)("inlineCode",{parentName:"li"},"PAIR"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"UNPAIR"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"CAR"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"CDR"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"LEFT"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"RIGHT")," instructions, and ",(0,r.kt)("inlineCode",{parentName:"li"},"list"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"map"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"set")," composite types."),(0,r.kt)("li",{parentName:"ul"},"contract communication: ",(0,r.kt)("inlineCode",{parentName:"li"},"CONTRACT"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"TRANSFER_TOKENS")," instructions.")),(0,r.kt)("h3",{id:"gas-model"},"Gas model"),(0,r.kt)("p",null,'A cost in "gas" (i.e. the money that must be paid in order to execute the instructions) is associated with the execution of a Michelson instruction. This "gas" modelling prevents the execution from creating an infinite loop. '),(0,r.kt)("p",null,"It also represents and rewards the work that bakers have to endure to validate a transaction."),(0,r.kt)("p",null,"Adding more memory space to the storage of a smart contract also has a cost (for each allocated byte)."),(0,r.kt)("p",null,"When invoking a smart contract, one must specify an amount of gas that will be spent for the execution of the code."),(0,r.kt)("h2",{id:"deployment---address-and-balance"},"Deployment - Address and balance"),(0,r.kt)("p",null,"In order to be accessible to anyone on the Tezos network, a smart contract must be deployed. This deployment phase is called ",(0,r.kt)("strong",{parentName:"p"},"origination"),"."),(0,r.kt)("p",null,"Tezos smart contracts have built-in internal information available once the smart contract has been deployed:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("strong",{parentName:"li"},"address")," of the smart contract is a unique identifier."),(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("strong",{parentName:"li"},"balance")," represents the quantity of XTZ associated with a smart contract. The smallest divisible part of a tez is a mutez (1 tez = 1,000,000 mutez).")),(0,r.kt)("h2",{id:"invocation-and-transaction-return-list-of-operations-storage"},"Invocation and transaction return (list of operations, storage)"),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"invocation")," of a smart contract is an explicit call for executing the code of the smart contract. It requires a call parameter which is a tuple of two elements (",(0,r.kt)("inlineCode",{parentName:"p"},"PAIR"),") containing:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a value of the entrypoint"),(0,r.kt)("li",{parentName:"ul"},"the value of the storage (current storage state)")),(0,r.kt)("p",null,"The invocation of the smart contract is expected to produce a tuple of two elements (",(0,r.kt)("inlineCode",{parentName:"p"},"PAIR"),") containing:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a list of operations (which are new transactions generated by this invocation)."),(0,r.kt)("li",{parentName:"ul"},"the new storage state.")),(0,r.kt)("p",null,"This list of operations represents all of the impacts your contract will have on the rest of the Tezos blockchain.\nThe new storage state represents the impact your invocation will have on the contract storage."),(0,r.kt)("p",null,'The diagram below describes the execution of the "empty smart contract" (seen in the previous section). Although this contract does not modify anything, it still has to fulfil the mentioned expectations (input and output format). '),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(6305).Z})),(0,r.kt)("small",{className:"figure"},"FIGURE 3: Execution of `CDR ; NIL operation ; PAIR`"),(0,r.kt)("p",null,"Notice that this script performs no modifications. Storage is given as a parameter and returned."),(0,r.kt)("h2",{id:"explicit-failure"},"Explicit failure"),(0,r.kt)("p",null,"When invoking a smart contract, the execution of the sequence of instructions may finish. In this case, the transaction is considered finalized. If the execution of the sequence of instructions stops before the end, the transaction is considered to be rejected. The following sections will introduce the Michelson instruction",(0,r.kt)("inlineCode",{parentName:"p"},"FAIL")," which is responsible for throwing an error (for stopping the execution). "),(0,r.kt)("p",null,'Now, let\'s deep dive into the Michelson language with the "tutorial" section.'))}p.isMDXComponent=!0},5292:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_entrypoint_or_example-e75998e31498c1d331fabc94ccda44e8.svg"},6305:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_smartcontract_basics-1e6ca476f5a13cceedbda97b25b68ce8.svg"},4563:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_stack_basics-30878fc533b4a72010b3bbcdc5219e98.svg"}}]);