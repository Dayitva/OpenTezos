(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[1976],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return p},kt:function(){return f}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,s=e.originalType,c=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=l(t),f=o,h=d["".concat(c,".").concat(f)]||d[f]||u[f]||s;return t?a.createElement(h,i(i({ref:n},p),{},{components:t})):a.createElement(h,i({ref:n},p))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var s=t.length,i=new Array(s);i[0]=d;var r={};for(var c in n)hasOwnProperty.call(n,c)&&(r[c]=n[c]);r.originalType=e,r.mdxType="string"==typeof e?e:o,i[1]=r;for(var l=2;l<s;l++)i[l]=t[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9158:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return i},metadata:function(){return r},toc:function(){return c},default:function(){return p}});var a=t(2122),o=t(9756),s=(t(7294),t(3905)),i={id:"basics",disable_pagination:!0,title:"Build a dapp - basics"},r={unversionedId:"dapp/basics",id:"dapp/basics",isDocsHomePage:!1,title:"Build a dapp - basics",description:"Now that we have a deployed contract and a ready-to-use Wallet, we can start to develop a frontend that will interact",source:"@site/docs/dapp/front.md",sourceDirName:"dapp",slug:"/dapp/basics",permalink:"/dapp/basics",editUrl:"https://github.com/octo-technology/OpenTezos/tree/main/docs/dapp/front.md",version:"current",lastUpdatedBy:"bepi-octo",lastUpdatedAt:1622637999,formattedLastUpdatedAt:"6/2/2021",frontMatter:{id:"basics",disable_pagination:!0,title:"Build a dapp - basics"},sidebar:"docs",previous:{title:"Temple Wallet",permalink:"/dapp/temple"},next:{title:"Build a dapp - User Experience",permalink:"/dapp/front_user_experience"}},c=[{value:"Wallet connexion",id:"wallet-connexion",children:[]},{value:"Wallet information",id:"wallet-information",children:[]},{value:"Big map handling",id:"big-map-handling",children:[]},{value:"New raffle information",id:"new-raffle-information",children:[{value:"DatePicker installation",id:"datepicker-installation",children:[]},{value:"Form creation",id:"form-creation",children:[]}]},{value:"New raffle button",id:"new-raffle-button",children:[{value:"web3 installation",id:"web3-installation",children:[]},{value:"Implementation",id:"implementation",children:[]}]},{value:"End-to-end testing",id:"end-to-end-testing",children:[]},{value:"Implementation",id:"implementation-1",children:[]},{value:"End-to-end testing",id:"end-to-end-testing-1",children:[]}],l={toc:c};function p(e){var n=e.components,i=(0,o.Z)(e,["components"]);return(0,s.kt)("wrapper",(0,a.Z)({},l,i,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Now that we have a deployed contract and a ready-to-use Wallet, we can start to develop a frontend that will interact\nwith a raffle smart contract."),(0,s.kt)("p",null,"This chapter requires knowledge about CSS, React and React Hooks. This is not a tutorial about React, nor how to build a\nnice UI. This tutorial shows the basics usage of Temple in a dapp use case"),(0,s.kt)("h1",{id:"project-initialisation"},"Project initialisation"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"$ npx create-react-app my-dapp --template typescript\n$ cd my-dapp\n$ yarn start\n")),(0,s.kt)("p",null,"We have a running React application, that displays some text. So far, it does not do anything. The first step is to\nintegrate the Temple Wallet within our app."),(0,s.kt)("h1",{id:"temple-integration"},"Temple Integration"),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@temple-wallet/dapp"},"temple-wallet/dapp")," module enables a React application to use\nthe Temple Wallet to interact with a Tezos blockchain. Let's install this module:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"$ yarn add @temple-wallet/dapp\n$ yarn add @taquito/taquito\n$ yarn add constate\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("em",{parentName:"p"},"Madfish Solutions")," team provides developers with a ready-to-use script, which integrates the Temple Wallet into our\nReact app:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/madfish-solutions/counter-dapp/blob/master/src/dapp.js"},"https://github.com/madfish-solutions/counter-dapp/blob/master/src/dapp.js")),(0,s.kt)("p",null,"Let's create a ",(0,s.kt)("inlineCode",{parentName:"p"},"dapp")," folder into ",(0,s.kt)("inlineCode",{parentName:"p"},"src/"),", and put the dapp.js file into it:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"$ mkdir src/dapp\n$ cd src/dapp\n$ curl https://raw.githubusercontent.com/madfish-solutions/counter-dapp/master/src/dapp.js -O\n")),(0,s.kt)("p",null,"It exports a ",(0,s.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/context.html"},"React context")," and the necessary functions to interact with a Tezos\nnetwork:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"DAppProvider"),": React context that will contain all the below hooks"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"useWallet"),": returns a Wallet instance"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"useTezos"),": returns a TezosToolkit, using the wallet instance"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"useAccountPkh"),": returns the current wallet account address"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"useReady"),": returns a boolean indicating if the wallet is connected to the tezos network"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"useConnect"),": react callback to change the used account"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"useOnBlock"),": react effect to retrieve the latest baked block. It subscribe to the stream of block (watching head),\nthanks to the ",(0,s.kt)("inlineCode",{parentName:"li"},"SubscribeProvider")," ",(0,s.kt)("em",{parentName:"li"},"Taquito")," class.")),(0,s.kt)("p",null,"These hooks will connect our React frontend to the Temple wallet extension."),(0,s.kt)("p",null,"Let's modify the src/App.tsx.\nWe will remove all the HTML element, and we will add the ",(0,s.kt)("inlineCode",{parentName:"p"},"DAppProvider")," context, from the ",(0,s.kt)("inlineCode",{parentName:"p"},"dapp/dapp.js")," file."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// dapp/dapp.js\nfunction useDApp({ appName }) {\n  const [{ wallet, tezos, accountPkh }, setState] = React.useState(() => ({\n    wallet: undefined,\n    tezos: undefined,\n    accountPkh: undefined,\n  }))\n\n  const ready = Boolean(tezos)\n\n  React.useEffect(() => {\n    return TempleWallet.onAvailabilityChange((available) => {\n      setState({\n        wallet: available ? new TempleWallet(appName) : undefined,\n        tezos: undefined,\n        accountPkh: undefined,\n      })\n    })\n  }, [setState, appName])\n\n//...\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"useDApp"),' expects one argument, which is the app name. Let\'s call our application "Raffle", and put its name into a constants file in ',(0,s.kt)("inlineCode",{parentName:"p"},"src/dapp/default.ts")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"// src/dapp/default.ts\nexport const APP_NAME = 'Raffle';\n")),(0,s.kt)("p",null,"We can add the context into ",(0,s.kt)("inlineCode",{parentName:"p"},"src/App.tsx"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"// src/App.tsx\nimport React from 'react';\nimport { DAppProvider } from \"dapp/dapp\";\nimport { APP_NAME } from './dapp/defaults';\nimport './App.css';\n\nfunction App() {\n    return (\n        <DAppProvider appName={APP_NAME}>\n            <React.Suspense fallback={null}>\n\n            </React.Suspense>\n        < /DAppProvider>\n    );\n}\n\nexport default App;\n\n")),(0,s.kt)("h2",{id:"wallet-connexion"},"Wallet connexion"),(0,s.kt)("p",null,"The first step is to connect our react app to the Temple Wallet."),(0,s.kt)("p",null,"Let's create a ",(0,s.kt)("inlineCode",{parentName:"p"},"Page")," component, that will contain all our component"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"import React from 'react';\nimport { DAppProvider } from './dapp/dapp'\nimport './App.css';\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className=\"App\"> {props.children} </div>\n}\n\nfunction App() {\n  return (\n          <DAppProvider appName={APP_NAME}>\n            <React.Suspense fallback={null}>\n              <Page> </Page>\n            </React.Suspense>\n          </DAppProvider>\n  );\n}\n\nexport default App;\n")),(0,s.kt)("p",null,"Let's add a connexion button: when it is clicked, the app connects to the temple wallet.\nWe will use the ",(0,s.kt)("inlineCode",{parentName:"p"},"useConnect")," hook from ",(0,s.kt)("inlineCode",{parentName:"p"},"src/dapp/dapp.js"),". Let's take a look at this callback definition:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// src/dapp/dapp.js\nconst connect = React.useCallback(\n    async (network, opts) => {\n      try {\n        if (!wallet) {\n          throw new Error('Thanos Wallet not available')\n        }\n        await wallet.connect(network, opts) // expects a network and some options\n        const tzs = wallet.toTezos()\n        const pkh = await tzs.wallet.pkh()\n        setState({\n          wallet,\n          tezos: tzs,\n          accountPkh: pkh,\n        })\n      } catch (err) {\n        console.error(`Failed to connect ThanosWallet: ${err.message}`)\n      }\n    },\n    [setState, wallet],\n  )\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"useConnect")," expects two arguments: a Tezos network and some options. Let's define a ",(0,s.kt)("inlineCode",{parentName:"p"},"NETWORK")," global variable into ",(0,s.kt)("inlineCode",{parentName:"p"},"dapp/default.ts")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"// src/dapp/default.ts\nexport const APP_NAME = 'Raffle';\nexport const NETWORK = 'edo2net';\n")),(0,s.kt)("p",null,"Our smart contract is deployed on edonet: the network is therefore set to ",(0,s.kt)("inlineCode",{parentName:"p"},"edo2net"),"."),(0,s.kt)("p",null,"We can now use the ",(0,s.kt)("inlineCode",{parentName:"p"},"useConnect")," callback. We define a ",(0,s.kt)("inlineCode",{parentName:"p"},"ConnexionButton")," component, that will execute a connexion callback when clicked.\nThe application connects the wallet to the specified ",(0,s.kt)("inlineCode",{parentName:"p"},"NETWORK")," (edonet in our case).\nWe add the option ",(0,s.kt)("inlineCode",{parentName:"p"},"forcePermission: true")," to force a new connexion if the button is clicked with an already authenticated user"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"function ConnexionButton() {\n  const connect = useConnect()\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n  return <button onClick={handleConnect}>Connect account</button>\n}\n")),(0,s.kt)("p",null,"The app looks now:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"import React from 'react';\nimport { DAppProvider, useConnect } from './dapp/dapp'\nimport './App.css';\nimport { APP_NAME, NETWORK } from './dapp/defaults';\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className=\"App\"> {props.children} </div>\n}\n\nfunction ConnexionButton() {\n  const connect = useConnect()\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n  return <button onClick={handleConnect}>Connect account</button>\n}\n\nfunction App() {\n  return (\n          <DAppProvider appName={APP_NAME}>\n            <React.Suspense fallback={null}>\n              <Page>\n                <ConnexionButton></ConnexionButton>\n              </Page>\n            </React.Suspense>\n          </DAppProvider>\n  );\n}\n\nexport default App;\n")),(0,s.kt)("p",null,"Our application contains a single button: if we push it, a pop-up appears and offers the user the possibility to connect to the address of its choice."),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(1631).Z})),(0,s.kt)("h2",{id:"wallet-information"},"Wallet information"),(0,s.kt)("p",null,"Our application now connects to an account, with the Temple Wallet.\nHowever, the application does not display some crucial information: the used address and its balance.\nThe user needs to know which address is going to interact with the smart contract, and will therefore need some funds."),(0,s.kt)("p",null,"Let's add the used address. We will use the ",(0,s.kt)("inlineCode",{parentName:"p"},"useAccountPkh")," callback from ",(0,s.kt)("inlineCode",{parentName:"p"},"dapp/dapp.js"),".\nThe information is set when the connexion is established:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"  const connect = React.useCallback(\n        async (network, opts) => {\n          try {\n            if (!wallet) {\n              throw new Error('Thanos Wallet not available')\n            }\n            await wallet.connect(network, opts)\n            const tzs = wallet.toTezos()\n            const pkh = await tzs.wallet.pkh()\n            setState({\n              wallet,\n              tezos: tzs,\n              accountPkh: pkh, // set here\n            })\n          } catch (err) {\n            console.error(`Failed to connect ThanosWallet: ${err.message}`)\n          }\n        },\n        [setState, wallet],\n)\n")),(0,s.kt)("p",null,"We will call the ",(0,s.kt)("inlineCode",{parentName:"p"},"useAccountPkh")," hook, and reformat the address.\nThe user needs to know which address he is using but does not need to know the full address: the beginning and the end of the address is enough."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"function ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n\n  const accountPkhPreview = React.useMemo(() => {\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}` \n    }\n  }, [accountPkh]) // updates when the connected account changes\n//..\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"accountPkhPreview")," variable must be updated when the connected account changes"),(0,s.kt)("p",null,"Next, we will display the balance associated to the connected account.\nWe will need to interact with the Tezos network, so we will need the ",(0,s.kt)("inlineCode",{parentName:"p"},"useTezos")," hook.\nThe balance is likely to change when:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the network changes"),(0,s.kt)("li",{parentName:"ul"},"the account changes"),(0,s.kt)("li",{parentName:"ul"},"a new block is baked"),(0,s.kt)("li",{parentName:"ul"},"the app is ")),(0,s.kt)("p",null,"We will write our balance update into a react callback, what will be updated if the network, connected account or the page changes."),(0,s.kt)("p",null,"This callback will be used in a effect (if the callback has changed).\nIt will also be used in the ",(0,s.kt)("inlineCode",{parentName:"p"},"useOnBlock")," hook. When a new block is baked, the app will update the balance if it has changed."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const loadBalance = React.useCallback(async () => {\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format('mutez', 'tz', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n")),(0,s.kt)("p",null,"Let's change our component into an array of three elements: the balance, the connected user, and the connect button"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"function ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n\n  const accountPkhPreview = React.useMemo(() => {\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}`\n    }\n  }, [accountPkh])\n\n  const loadBalance = React.useCallback(async () => {\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format('mutez', 'tz', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n\n  return <div style={{ display: \"grid\", gridTemplateColumns: '1fr 1fr 1fr', margin: '0 auto', width: \"500px\" }}>\n      <div>{balance}</div>\n      <div>{accountPkhPreview}</div>\n      <button onClick={handleConnect}>Connect account</button>\n    </div>\n}\n")),(0,s.kt)("h1",{id:"displaying-storage"},"Displaying Storage"),(0,s.kt)("p",null,"So far, our application uses the Temple Wallet to connect to a Tezos network, with an address. It is time now to connect our React application to our Raffle smart contract and then to retrieve the contract information (entrypoints and storage)"),(0,s.kt)("p",null,"Let's create a new component, that will display the information from the storage. First, we need to retrieve the contract.\nWe will need:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the contract address"),(0,s.kt)("li",{parentName:"ul"},"to connect to a Tezos network, so we will use the ",(0,s.kt)("inlineCode",{parentName:"li"},"useTezos")," hook"),(0,s.kt)("li",{parentName:"ul"},"to save the contract into the component state"),(0,s.kt)("li",{parentName:"ul"},"to reload the contract whenever the tezos toolkit changes")),(0,s.kt)("p",null,"We will put the logic that retrieves the contract into an effect like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"function RaffleInformation() {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  return (\n    <div>\n    </div>\n\n  );\n};\n")),(0,s.kt)("p",null,"The contract object holds several pieces of information:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the address"),(0,s.kt)("li",{parentName:"ul"},"the entrypoints"),(0,s.kt)("li",{parentName:"ul"},"the code and storage definition")),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(4507).Z})),(0,s.kt)("p",null,"Let's now take a look at the contract storage.\nThe storage will be kept within the component state.\nLet's define a ",(0,s.kt)("inlineCode",{parentName:"p"},"RaffleStorage")," type, that will follows the storage definition"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"type RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"BigMapAbstraction")," is an abstraction exported by ",(0,s.kt)("inlineCode",{parentName:"p"},"@taquito/taquito"),": it allows the application to handle ",(0,s.kt)("a",{parentName:"p",href:"https://tezostaquito.io/typedoc/classes/_taquito_taquito.bigmapabstraction.html"},"maps and big maps")),(0,s.kt)("p",null,"Let's fetch the storage from the contract. We will the put logic of fetching the storage in a react callback ",(0,s.kt)("inlineCode",{parentName:"p"},"loadStorage"),".\nThe storage is likely to change if the contract object changes and if a new block is baked. So, this callback will be called in an effect and in the ",(0,s.kt)("inlineCode",{parentName:"p"},"useOnBlock")," hook"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"\ntype RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n\n\n\nfunction RaffleInformation() {\n  const tezos = useTezos();\n  const [contract, setContract] = useState();\n  const [tickets, setTickets] = useState<string[]>([]);\n\n  useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n    const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      setStorage(str)\n    }\n  }, [contract]);\n\n    React.useEffect(() => {\n    loadStorage();\n  }, [loadStorage]);\n\n  useOnBlock(tezos, loadStorage)\n\n  return (\n    <div>\n    </div>\n\n  );\n};\n")),(0,s.kt)("p",null,"One example of a retrieved storage is:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'admin: "tz1cGftgD3FuBmBhcwY24RaMm5D2UXLr5LHW"\nclose_date: "2021-07-23T12:59:48.000Z"\ndescription: "Test from dapp"\njackpot: BigNumber {s: 1, e: 1, c: Array(1)}\nplayers: (3) ["tz1beoZXxjqsXGoZnwW4TZD3MWGFpLHRxeFN", "tz1cGftgD3FuBmBhcwY24RaMm5D2UXLr5LHW", "tz1cLMENL1FJYMBJ3WPg5UQAEFobdVPFrdpH"]\nraffle_is_open: true\nsold_tickets: BigMapAbstraction {id: BigNumber, schema: Schema, provider: RpcContractProvider}\nwinning_ticket_number_hash: "74657374"\n\n')),(0,s.kt)("p",null,"Almost all the values are fetched with ",(0,s.kt)("inlineCode",{parentName:"p"},"contract.storage()"),", except the ",(0,s.kt)("inlineCode",{parentName:"p"},"sold_tickets"),"  big map."),(0,s.kt)("h2",{id:"big-map-handling"},"Big map handling"),(0,s.kt)("p",null,"Big maps cannot be directly handled with taquito. This comes as no surprise. Indeed big maps are meant to store a huge amount of data: retrieving the whole big map can take a long time. That's why the wallet returns a ",(0,s.kt)("inlineCode",{parentName:"p"},"BigMapAbstraction"),". This object will be used to retrieved specific values of the big map."),(0,s.kt)("p",null,"In our case, we want to display the tickets and their owner: we need to retrieve all the values. For that, we need to know the keys, which mean we need to know the sold ticket ids. When this article was written, ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/ecadlabs/taquito/projects/2#card-34204687"},"big map keys discovery")," was not yet implemented."),(0,s.kt)("p",null,"Usually, there are two ways of getting big map keys:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"making an api call on an ",(0,s.kt)("a",{parentName:"li",href:"/explorer/tzstats-smart-contract/#api-calls"},"indexer api"),". An indexer monitors a tezos network and extract and transform data so they can be easily fetched. Those indexers retrieve the contract big maps, which can be read on an API endpoint. First, you need to retrieve the big map number. You can find this number in the ",(0,s.kt)("inlineCode",{parentName:"li"},"BigMapAbstraction")," or from an explorer. Once you have this number, you can fetch its keys (and values) with an API key (we use ",(0,s.kt)("a",{parentName:"li",href:"https://tzstats.com/"},"tzstats"),")")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'$ GET https://api.edo.tzstats.com/explorer/bigmap/108024/keys\n[{"key":"0","key_hash":"exprtZBwZUeYYYfUs9B9Rg2ywHezVHnCCnmF9WsDQVrs582dSK63dC","key_binary":"0"},{"key":"1","key_hash":"expru2dKqDfZG8hu4wNGkiyunvq2hdSKuVYtcKta7BWP6Q18oNxKjS","key_binary":"1"},{"key":"2","key_hash":"expruDuAZnFKqmLoisJqUGqrNzXTvw7PJM2rYk97JErM5FHCerQqgn","key_binary":"2"}]\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"refactoring the smart contract: the big map keys can be kept into a ",(0,s.kt)("inlineCode",{parentName:"li"},"set"),".")),(0,s.kt)("p",null,"In our raffle smart contracts, we don't need this. There is a one-to-one correspondence between the tickets and the players: if there are five players, it means that exactly five sold tickets. Since all tickets are numbered in the ascending order, we can infer that the big map keys range from zero to four."),(0,s.kt)("p",null,"So, we will create an array of number, which range from ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"players.length"),".\nNow that we have our keys, we will retrieve the mapped values."),(0,s.kt)("p",null,"A ",(0,s.kt)("inlineCode",{parentName:"p"},"BigMapAbstraction")," exposes two asynchronous methods: "),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get"),": takes a big map key as input. Fetches one value"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"getMultipleValues"),": takes a list of big map key as input. Fetches several values at the same time")),(0,s.kt)("p",null,"The correct way to retrieve several values is to use ",(0,s.kt)("inlineCode",{parentName:"p"},"getMultipleValues")," when we need to get several values. Putting ",(0,s.kt)("inlineCode",{parentName:"p"},"get")," into a ",(0,s.kt)("inlineCode",{parentName:"p"},"for")," loop to retrieve n values will make n calls: it is not effective when the big map grows."),(0,s.kt)("p",null,"Our ",(0,s.kt)("inlineCode",{parentName:"p"},"loadStorage")," callback now looks like:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"    const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      const ticket_ids = Array.from(Array(str.players.length).keys()) // creating the keys array\n      const tckts = await str.sold_tickets.getMultipleValues(ticket_ids) // fetching the values\n      setStorage(str)\n      setTickets([...tckts.valueMap])\n\n    }\n  }, [contract]);\n")),(0,s.kt)("p",null,"Finally, our storage information will be display as plain text. Our Raffle app is:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'import React, { useState } from \'react\';\nimport { DAppProvider, useAccountPkh, useConnect, useOnBlock, useReady, useTezos, useWallet } from \'./dapp/dapp\'\nimport \'./App.css\';\nimport { APP_NAME, NETWORK, RAFFLE_ADDRESS } from \'./dapp/defaults\';\nimport { BigMapAbstraction } from "@taquito/taquito";\n\ntype RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className="App"> {props.children} </div>\n}\n\n\n\nfunction ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n\n  const accountPkhPreview = React.useMemo(() => {\n    console.log("usememo")\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}`\n    }\n  }, [accountPkh])\n\n  const loadBalance = React.useCallback(async () => {\n    console.log(loadBalance)\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format(\'mutez\', \'tz\', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n\n  return <div>\n    <div style={{ display: "grid", gridTemplateColumns: \'1fr 1fr 1fr\', margin: \'0 auto\', width: "500px" }}>\n      <div>{balance}</div>\n      <div>{accountPkhPreview}</div>\n      <button onClick={handleConnect}>Connect account</button>\n    </div>\n  </div>\n\n}\n\nfunction RaffleInformation() {\n  const wallet = useWallet();\n  const ready = useReady();\n  const tezos = useTezos();\n\n  const [contract, setContract] = useState();\n  const [storage, setStorage] = useState<RaffleStorage>();\n  const [tickets, setTickets] = useState<string[]>([]);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      const ticket_ids = Array.from(Array(str.players.length).keys())\n      const tckts = await str.sold_tickets.getMultipleValues(ticket_ids)\n      setStorage(str)\n      setTickets([...tckts.valueMap])\n    }\n  }, [contract]);\n\n  React.useEffect(() => {\n    loadStorage();\n  }, [loadStorage]);\n\n  useOnBlock(tezos, loadStorage)\n\n  return (\n    <div>\n      <div>\n        Administrator: {!!storage ? storage.admin.toString() : ""}\n      </div>\n      <div>\n        Reward: {!!storage ? storage.jackpot.toString() : ""}\n      </div>\n      <div>\n        Description: {!!storage ? storage.description.toString() : ""}\n      </div>\n      <div>\n        Players:\n        <div>\n          {!!storage ? storage.players.map((value, index) => {\n            return <li key={index}>{value}</li>\n          }) : ""}\n        </div>\n      </div>\n      <div>\n        Tickets sold:\n        <div>\n          {tickets.map((value, index) => {\n            return <li key={index}>{value[0]} : {value[1]}</li>\n          })}\n        </div>\n      </div>\n\n      <div>\n        Closing date: {!!storage ? storage.close_date.toString() : ""}\n      </div>\n    </div>\n\n  );\n};\n\nfunction App() {\n  return (\n    <DAppProvider appName={APP_NAME}>\n      <React.Suspense fallback={null}>\n        <Page>\n          <ConnectionSection></ConnectionSection>\n          <RaffleInformation></RaffleInformation>\n        </Page>\n      </React.Suspense>\n    </DAppProvider>\n  );\n}\n\nexport default App;\n')),(0,s.kt)("h1",{id:"launching-a-new-raffle"},"Launching a new raffle"),(0,s.kt)("p",null,"It is time now to add interactions with the smart contract: let's add the possibility to launch a raffle. For this, the user will have to enter the raffle pieces of information, and then to call the ",(0,s.kt)("inlineCode",{parentName:"p"},"openRaffle")," entrypoint."),(0,s.kt)("p",null,"Let's create a ",(0,s.kt)("inlineCode",{parentName:"p"},"LaunchRaffleSection")," component, that will contains a ",(0,s.kt)("inlineCode",{parentName:"p"},"form")," to enter the raffle information, and a button to call the entrypoint."),(0,s.kt)("h2",{id:"new-raffle-information"},"New raffle information"),(0,s.kt)("p",null,"First, we will add a form. Four pieces of information are needed:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the ",(0,s.kt)("strong",{parentName:"li"},"reward"),": it will be entered as a ",(0,s.kt)("inlineCode",{parentName:"li"},"string")),(0,s.kt)("li",{parentName:"ul"},"the ",(0,s.kt)("strong",{parentName:"li"},"description"),": it will be entered as a ",(0,s.kt)("inlineCode",{parentName:"li"},"string")),(0,s.kt)("li",{parentName:"ul"},"the ",(0,s.kt)("strong",{parentName:"li"},"closing date"),": it will be entered as a ",(0,s.kt)("inlineCode",{parentName:"li"},"Date")),(0,s.kt)("li",{parentName:"ul"},"the ",(0,s.kt)("strong",{parentName:"li"},"winning ticket hash"),": it will entered a ",(0,s.kt)("inlineCode",{parentName:"li"},"string"))),(0,s.kt)("p",null,"For the reward, description and winning ticket hash, a simple ",(0,s.kt)("inlineCode",{parentName:"p"},"<input>")," component will be enough. For the closing date, we will use a ",(0,s.kt)("inlineCode",{parentName:"p"},"DatePicker")," (","[https://www.npmjs.com/package/react-datepicker]",")."),(0,s.kt)("p",null,"These four pieces of information will be kept into the component state."),(0,s.kt)("h3",{id:"datepicker-installation"},"DatePicker installation"),(0,s.kt)("p",null,"Let's add the ",(0,s.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/react-datepicker"},"react-datepicker")," package:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"$ yarn add react-datepicker\n")),(0,s.kt)("p",null,"We then need two add two imports into ",(0,s.kt)("em",{parentName:"p"},"App.tsx"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'import DatePicker from "react-datepicker";\nimport "react-datepicker/dist/react-datepicker.css";\n')),(0,s.kt)("h3",{id:"form-creation"},"Form creation"),(0,s.kt)("p",null,"The raffle information will be entered in a basic React component like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'\nfunction LaunchRaffleSection() {\n  const [description, setDescription] = useState("");\n  const [reward, setReward] = useState("100");\n  const [closingDate, setClosingDate] = useState(new Date());\n  const [winningTicketHash, setwinningTicketHash] = useState("");\n\n  const setNewDate = (date: any) => {\n    if (!!date) {\n      setClosingDate(date)\n    }\n  }\n\n  return <div style={{ border: "1px solid black" }}>\n    <form>\n      <label>\n        Reward:\n  <input type="text" name="reward" value={reward}\n          onChange={(e) => setReward(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Description:\n  <input type="text" name="description" value={description}\n          onChange={(e) => setDescription(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Closing Date:\n    <DatePicker selected={closingDate} onChange={date => setNewDate(date)}></DatePicker>\n      </label>\n      <br />\n      <label>\n        Winning Hash number:\n    <input type="text" name="winningTicketHash" value={winningTicketHash}\n          onChange={(e) => setwinningTicketHash(e.target.value)} />\n      </label>\n    </form>\n  </div>\n\n}\n')),(0,s.kt)("h2",{id:"new-raffle-button"},"New raffle button"),(0,s.kt)("h3",{id:"web3-installation"},"web3 installation"),(0,s.kt)("p",null,"In this part, we will need the standard ",(0,s.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/web3"},"web3 package"),". It is used to interact with ",(0,s.kt)("em",{parentName:"p"},"Ethereum")," networks. In our case, we will use the ",(0,s.kt)("inlineCode",{parentName:"p"},"utils.asciiToHex")," function, to convert string into bytes"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"$ yarn add web3\n")),(0,s.kt)("h3",{id:"implementation"},"Implementation"),(0,s.kt)("p",null,"The raffle information entered by the user will be used during the contract call. First, let's add a button that will trigger this call."),(0,s.kt)("p",null,"Let's create a ",(0,s.kt)("inlineCode",{parentName:"p"},"LaunchRaffleButton")," component. This component will contain the contract call logic."),(0,s.kt)("p",null,"We will call the ",(0,s.kt)("inlineCode",{parentName:"p"},"openRaffle")," entrypoint: it needs the four pieces of information from the form. Let's create a props type for this component:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"type launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n\n}\n")),(0,s.kt)("p",null,"Before making this contract call, we need to connect to the tezos network (using the ",(0,s.kt)("inlineCode",{parentName:"p"},"useTezos")," hook) and to get the contract (the same way as for the ",(0,s.kt)("inlineCode",{parentName:"p"},"RaffleInformation"),") component."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"type launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n}\n")),(0,s.kt)("p",null,"The next step is to create the callback that will perform the contract call. This callback will receive the same four arguments as the component. This callback is likely to change if the contract changes."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ContractAbstraction")," holds the callable entrypoints in ",(0,s.kt)("inlineCode",{parentName:"p"},"methods"),". "),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(4923).Z})),(0,s.kt)("p",null,"It returns three callbacks, matching our three entrypoints: we will use the ",(0,s.kt)("inlineCode",{parentName:"p"},"openRaffle")," function. It expects four arguments: the order the arguments are expected is can be found in ",(0,s.kt)("inlineCode",{parentName:"p"},"entrypoints")," in the ",(0,s.kt)("inlineCode",{parentName:"p"},"ContractAbstraction"),"."),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(9503).Z})),(0,s.kt)("p",null,"The order is given by the type order:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"reward (",(0,s.kt)("inlineCode",{parentName:"li"},"mutez"),")"),(0,s.kt)("li",{parentName:"ol"},"closing date (",(0,s.kt)("inlineCode",{parentName:"li"},"timestamps"),")"),(0,s.kt)("li",{parentName:"ol"},"description (",(0,s.kt)("inlineCode",{parentName:"li"},"option"),")"),(0,s.kt)("li",{parentName:"ol"},"winning ticket hash (",(0,s.kt)("inlineCode",{parentName:"li"},"bytes"),")")),(0,s.kt)("p",null,"We can write our callback"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n    },\n    [contract]\n  );\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"web3.utils.asciiToHex(string).slice(2)")," is the way to convert a string into a bytes, using the standard ",(0,s.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/web3"},"web3 package"),"."),(0,s.kt)("p",null,"However, even though the contract arguments are correct, the execution will fail. Indeed, when a raffle is opened, the reward must be sent to the smart contract: an ",(0,s.kt)("inlineCode",{parentName:"p"},"amount")," must be specified. It can be carried out with the ",(0,s.kt)("inlineCode",{parentName:"p"},"send")," method, which allow to specify some parameters of the call:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n        .send({ amount: reward });\n    },\n    [contract]\n  );\n")),(0,s.kt)("p",null,"The last thing is to connect this callback to a button. Our final component is:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"type launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n        .send({ amount: reward });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback({\n      reward: raffleReward,\n      description: raffleDescription,\n      closingDate: raffleClosingDate,\n      winningTicketHash: raffleWinningHashNumber\n    })\n  }}>Launch</button>\n}\n")),(0,s.kt)("h2",{id:"end-to-end-testing"},"End-to-end testing"),(0,s.kt)("p",null,"Our app now looks like: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'import React, { useState } from \'react\';\nimport { DAppProvider, useAccountPkh, useConnect, useOnBlock, useReady, useTezos, useWallet } from \'./dapp/dapp\'\nimport \'./App.css\';\nimport { APP_NAME, NETWORK, RAFFLE_ADDRESS } from \'./dapp/defaults\';\nimport { BigMapAbstraction } from "@taquito/taquito";\nimport DatePicker from "react-datepicker";\nimport "react-datepicker/dist/react-datepicker.css";\nimport web3 from "web3";\n\ntype RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className="App"> {props.children} </div>\n}\n\n\n\nfunction ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n\n  const accountPkhPreview = React.useMemo(() => {\n    console.log("usememo")\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}`\n    }\n  }, [accountPkh])\n\n  const loadBalance = React.useCallback(async () => {\n    console.log(loadBalance)\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format(\'mutez\', \'tz\', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n\n  return <div>\n    <div style={{ display: "grid", gridTemplateColumns: \'1fr 1fr 1fr\', margin: \'0 auto\', width: "500px" }}>\n      <div>{balance}</div>\n      <div>{accountPkhPreview}</div>\n      <button onClick={handleConnect}>Connect account</button>\n    </div>\n  </div>\n\n}\n\nfunction RaffleInformation() {\n  const wallet = useWallet();\n  const ready = useReady();\n  const tezos = useTezos();\n\n  const [contract, setContract] = useState();\n  const [storage, setStorage] = useState<RaffleStorage>();\n  const [tickets, setTickets] = useState<string[]>([]);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      const ticket_ids = Array.from(Array(str.players.length).keys())\n      const tckts = await str.sold_tickets.getMultipleValues(ticket_ids)\n      setStorage(str)\n      setTickets([...tckts.valueMap])\n    }\n  }, [contract]);\n\n  React.useEffect(() => {\n    loadStorage();\n  }, [loadStorage]);\n\n  useOnBlock(tezos, loadStorage)\n\n  return (\n    <div>\n      <div>\n        Administrator: {!!storage ? storage.admin.toString() : ""}\n      </div>\n      <div>\n        Reward: {!!storage ? storage.jackpot.toString() : ""}\n      </div>\n      <div>\n        Description: {!!storage ? storage.description.toString() : ""}\n      </div>\n      <div>\n        Players:\n        <div>\n          {!!storage ? storage.players.map((value, index) => {\n            return <li key={index}>{value}</li>\n          }) : ""}\n        </div>\n      </div>\n      <div>\n        Tickets sold:\n        <div>\n          {tickets.map((value, index) => {\n            return <li key={index}>{value[0]} : {value[1]}</li>\n          })}\n        </div>\n      </div>\n\n      <div>\n        Closing date: {!!storage ? storage.close_date.toString() : ""}\n      </div>\n    </div>\n\n  );\n};\n\ntype launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n        .send({ amount: reward });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback({\n      reward: raffleReward,\n      description: raffleDescription,\n      closingDate: raffleClosingDate,\n      winningTicketHash: raffleWinningHashNumber\n    })\n  }}>Launch</button>\n}\n\nfunction LaunchRaffleSection() {\n  const [description, setDescription] = useState("");\n  const [reward, setReward] = useState("100");\n  const [closingDate, setClosingDate] = useState(new Date());\n  const [winningTicketHash, setwinningTicketHash] = useState("");\n\n  const setNewDate = (date: any) => {\n    if (!!date) {\n      setClosingDate(date)\n    }\n  }\n\n  return <div style={{ border: "1px solid black" }}>\n    <form>\n      <label>\n        Reward:\n  <input type="text" name="reward" value={reward}\n          onChange={(e) => setReward(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Description:\n  <input type="text" name="description" value={description}\n          onChange={(e) => setDescription(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Closing Date:\n    <DatePicker selected={closingDate} onChange={date => setNewDate(date)}></DatePicker>\n      </label>\n      <br />\n      <label>\n        Winning Hash number:\n    <input type="text" name="winningTicketHash" value={winningTicketHash}\n          onChange={(e) => setwinningTicketHash(e.target.value)} />\n      </label>\n    </form>\n    <LaunchRaffleButton raffleReward={parseInt(reward)} raffleDescription={description} raffleClosingDate={closingDate} raffleWinningHashNumber={winningTicketHash} ></LaunchRaffleButton>\n  </div>\n\n}\n\nfunction App() {\n  return (\n    <DAppProvider appName={APP_NAME}>\n      <React.Suspense fallback={null}>\n        <Page>\n          <ConnectionSection></ConnectionSection>\n          <RaffleInformation></RaffleInformation>\n          <LaunchRaffleSection></LaunchRaffleSection>\n        </Page>\n      </React.Suspense>\n    </DAppProvider>\n  );\n}\n\nexport default App;\n')),(0,s.kt)("p",null,"Let's run it:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"$ yarn start\n")),(0,s.kt)("p",null,"The page should look like this:"),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(2131).Z})),(0,s.kt)("p",null,'Let\'s connect our wallet by clicking on "Connect account". A Temple pop-up appears and displays the available accounts:\n',(0,s.kt)("img",{src:t(1276).Z})),(0,s.kt)("p",null,"The account information are loaded and displayed:\n",(0,s.kt)("img",{src:t(9988).Z})),(0,s.kt)("p",null,"Let's create a new raffle: the closing date will be the same day, and there will be no winner. Let's click on launch. A pop-up appears, summing up the contract call:\n",(0,s.kt)("img",{src:t(6025).Z})),(0,s.kt)("p",null,'The detailed transaction information can be found under the "Raw" section\n',(0,s.kt)("img",{src:t(3230).Z}),'\nThere is a warning message: "Warning! Transaction is likely to fail". The Temple Wallet before sending the transaction can check if the Michelson code execution will succeed. In this case, the closing date is too early. Let\'s try to send the transaction. If we check in the console, an exception is raised.\n',(0,s.kt)("img",{src:t(1713).Z})),(0,s.kt)("p",null,"The cause of the failure is indeed the closing date. Let's try again: the reward will be 200 tz, and the end of the raffle will be a mont later:"),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(6125).Z})),(0,s.kt)("p",null,"The warning is gone. Instead, the fees are displayed. The transaction seems valid: let's send it. After a while, the UI is re-rendered:"),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(1972).Z})),(0,s.kt)("p",null,"A raffle just opened. 200 tz (the reward) have been substracted from our account balance and the raffle information have been updated."),(0,s.kt)("p",null,"We can try to launch a new raffle, but the transaction will fail since there is already an ongoing raffle. This is detected by the Temple Wallet."),(0,s.kt)("h1",{id:"buying-tickets"},"Buying tickets"),(0,s.kt)("h2",{id:"implementation-1"},"Implementation"),(0,s.kt)("p",null,"Let's add the feature of buying a ticket to our application. There is no information to provide: the only thing to do is to call the entrypoint."),(0,s.kt)("p",null,"Just like for the opening of a raffle, we will add a button component, that make that contract call when it is clicked.\nWe will need to interact with a contract on a tezos network, so we will use the ",(0,s.kt)("inlineCode",{parentName:"p"},"useTezos")," hook and the ",(0,s.kt)("inlineCode",{parentName:"p"},"RAFFLE_ADDRESS")," variable into an effect."),(0,s.kt)("p",null,"The logic of calling the ",(0,s.kt)("inlineCode",{parentName:"p"},"buyTicket")," entrypoint will be written into a React callback. The ticket costs one XTZ."),(0,s.kt)("p",null,"Note that ",(0,s.kt)("inlineCode",{parentName:"p"},"buyTicket")," expects ",(0,s.kt)("inlineCode",{parentName:"p"},"unit"),". It does not mean that he should not be passed any argument when call: it expect a ",(0,s.kt)("inlineCode",{parentName:"p"},'"unit"')," string"),(0,s.kt)("p",null,"Finally, this callback will be connected to button."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'function BuyTicketButton() {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const launchRaffleCallback = React.useCallback(\n    () => {\n      return (contract as any).methods\n        .buyTicket("unit")\n        .send({ amount: 1 });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback()\n  }}>Buy</button>\n}\n')),(0,s.kt)("h2",{id:"end-to-end-testing-1"},"End-to-end testing"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'import React, { useState } from \'react\';\nimport { DAppProvider, useAccountPkh, useConnect, useOnBlock, useReady, useTezos, useWallet } from \'./dapp/dapp\'\nimport \'./App.css\';\nimport { APP_NAME, NETWORK, RAFFLE_ADDRESS } from \'./dapp/defaults\';\nimport { BigMapAbstraction } from "@taquito/taquito";\nimport DatePicker from "react-datepicker";\nimport "react-datepicker/dist/react-datepicker.css";\nimport web3 from "web3";\n\ntype RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className="App"> {props.children} </div>\n}\n\n\n\nfunction ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n\n  const accountPkhPreview = React.useMemo(() => {\n    console.log("usememo")\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}`\n    }\n  }, [accountPkh])\n\n  const loadBalance = React.useCallback(async () => {\n    console.log(loadBalance)\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format(\'mutez\', \'tz\', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n\n  return <div>\n    <div style={{ display: "grid", gridTemplateColumns: \'1fr 1fr 1fr\', margin: \'0 auto\', width: "500px" }}>\n      <div>{balance}</div>\n      <div>{accountPkhPreview}</div>\n      <button onClick={handleConnect}>Connect account</button>\n    </div>\n  </div>\n\n}\n\nfunction RaffleInformation() {\n  const wallet = useWallet();\n  const ready = useReady();\n  const tezos = useTezos();\n\n  const [contract, setContract] = useState();\n  const [storage, setStorage] = useState<RaffleStorage>();\n  const [tickets, setTickets] = useState<string[]>([]);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        debugger\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      const ticket_ids = Array.from(Array(str.players.length).keys())\n      const tckts = await str.sold_tickets.getMultipleValues(ticket_ids)\n      setStorage(str)\n      setTickets([...tckts.valueMap])\n    }\n  }, [contract]);\n\n  React.useEffect(() => {\n    loadStorage();\n  }, [loadStorage]);\n\n  useOnBlock(tezos, loadStorage)\n\n  return (\n    <div>\n      <div>\n        Administrator: {!!storage ? storage.admin.toString() : ""}\n      </div>\n      <div>\n        Reward: {!!storage ? storage.jackpot.toString() : ""}\n      </div>\n      <div>\n        Description: {!!storage ? storage.description.toString() : ""}\n      </div>\n      <div>\n        Players:\n        <div>\n          {!!storage ? storage.players.map((value, index) => {\n            return <li key={index}>{value}</li>\n          }) : ""}\n        </div>\n      </div>\n      <div>\n        Tickets sold:\n        <div>\n          {tickets.map((value, index) => {\n            return <li key={index}>{value[0]} : {value[1]}</li>\n          })}\n        </div>\n      </div>\n\n      <div>\n        Closing date: {!!storage ? storage.close_date.toString() : ""}\n      </div>\n    </div>\n\n  );\n};\n\ntype launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n        .send({ amount: reward });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback({\n      reward: raffleReward,\n      description: raffleDescription,\n      closingDate: raffleClosingDate,\n      winningTicketHash: raffleWinningHashNumber\n    })\n  }}>Launch</button>\n}\n\nfunction LaunchRaffleSection() {\n  const [description, setDescription] = useState("");\n  const [reward, setReward] = useState("100");\n  const [closingDate, setClosingDate] = useState(new Date());\n  const [winningTicketHash, setwinningTicketHash] = useState("");\n\n  const setNewDate = (date: any) => {\n    if (!!date) {\n      setClosingDate(date)\n    }\n  }\n\n  return <div style={{ border: "1px solid black" }}>\n    <form>\n      <label>\n        Reward:\n  <input type="text" name="reward" value={reward}\n          onChange={(e) => setReward(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Description:\n  <input type="text" name="description" value={description}\n          onChange={(e) => setDescription(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Closing Date:\n    <DatePicker selected={closingDate} onChange={date => setNewDate(date)}></DatePicker>\n      </label>\n      <br />\n      <label>\n        Winning Hash number:\n    <input type="text" name="winningTicketHash" value={winningTicketHash}\n          onChange={(e) => setwinningTicketHash(e.target.value)} />\n      </label>\n    </form>\n    <LaunchRaffleButton raffleReward={parseInt(reward)} raffleDescription={description} raffleClosingDate={closingDate} raffleWinningHashNumber={winningTicketHash} ></LaunchRaffleButton>\n  </div>\n\n}\n\nfunction BuyTicketButton() {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const launchRaffleCallback = React.useCallback(\n    () => {\n      return (contract as any).methods\n        .buyTicket("unit")\n        .send({ amount: 1 });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback()\n  }}>Buy</button>\n}\n\nfunction App() {\n  return (\n    <DAppProvider appName={APP_NAME}>\n      <React.Suspense fallback={null}>\n        <Page>\n          <ConnectionSection></ConnectionSection>\n          <RaffleInformation></RaffleInformation>\n          <LaunchRaffleSection></LaunchRaffleSection>\n          <BuyTicketButton></BuyTicketButton>\n        </Page>\n      </React.Suspense>\n    </DAppProvider>\n  );\n}\n\nexport default App;\n')),(0,s.kt)("p",null,"Let's test it. The button to buy ticket has been added: it can be clicked. A Temple wallet pop-up appears, summing up the contract call."),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(1563).Z})),(0,s.kt)("p",null,"After a while, the UI is re-rendered: the bought ticket is displayed.\n",(0,s.kt)("img",{src:t(2318).Z})),(0,s.kt)("h1",{id:"conclusion"},"Conclusion"))}p.isMDXComponent=!0},1631:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front1-013427e8f1e012269215902cf92b5d08.png"},1713:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front10-48342678a3f6c70948f215e46383e638.png"},6125:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front11-e5be76b5f13c495363ace98bffab1e62.png"},1972:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front12-dc2fbda8b0dd7672447e7713d174fb6f.png"},1563:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front13-561b037cebca6e0111c45471cf4fb124.png"},2318:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front14-7a6342dd5f158456e9ac359b800599c8.png"},4507:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front2-ced586f3745bd9b4c03c1ffc4a0f7390.png"},4923:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front3-309923828c096cec2d28f0f2f71cf06e.png"},9503:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front4-42e98e5aa5a380f4dbbd52940524ad00.png"},2131:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front5-538d8a71a4b3124a8dc1e4e00e235150.png"},1276:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front6-521a214a72acb6954f3b0cbdc3c408cc.png"},9988:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front7-84a3ea0ef9a9de19c28488a4ae242b95.png"},6025:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front8-95b4f7d63da79d3bea7f688879447baf.png"},3230:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front9-d0a193dac6c95ec773cd3265088ac254.png"}}]);